\section{Formalization}~\label{sec:formalization}
In this section, we present the formal model \MIM{} (\emph{\textbf{F}eatherweight \textbf{H}ierarchical \textbf{J}ava}), based on
Featherweight Java~\cite{Igarashi01FJ}. The syntax, typing rules,
small-step semantics and theorems for type soundness are presented.

\vspace{-2ex}
\subsection{Syntax}
The abstract syntax of \MIM{} interface declarations, method declarations, and expressions is given at Figure~\ref{fig:syntax}. The multiple
inheritance feature of \MIM{} is inspired by Java 8 interfaces, which support
method implementations via default methods. This feature is 
closely related to \emph{traits}. To demonstrate how
unintentional method conflicts are untangled in \MIM{}, we only focus on a small subset of the interface model. For example, all the methods declared
in an interface are either default methods or abstract methods. Default methods provide default implementations for methods. Abstract methods do not
have method body, and in fact we are not introducing a different kind of methods, but they are just treated as normal methods that return empty. Abstract methods can be overridden with future implementations.

%From this point we can view that we
%are actually modelling a class model that supports multiple
%inheritance. 
Object creation is represented by $\new I$. If any unimplemented abstract methods are defined in interface $I$ (or inherited from parents), then object creation fails. Fields and primitive types are not modelled in \MIM{}.

The metavariables $I, J, K$ range over interface names; $x$ ranges over variables; $m$ ranges over method names; $e$ ranges over expressions; and $M$ ranges over method declarations. Following Featherweight Java, we assume that the set of variables includes the special variable \kwthis, which cannot be used as the name of an argument to a method. We use the same
conventions as FJ; we write $\overline{I}$ as shorthand for a possibly empty sequence $I_1, ..., I_n$, which may be indexed by $I_i$; and write $\overline{M}$ as shorthand for $M_1 .. M_n$ (with no commas). We also abbreviate operations on pairs of sequences in the obvious way, writing $\overline{I} \; \overline{x}$ for $I_1 \; x_1, ..., I_n \; x_n$, where $n$ is the length of $\overline{I}$ and $\overline{x}$.

In order to achieve multiple inheritance, an interface can have a set of 
parent interfaces, where such a set can be empty. The interface declaration $\interface{I}{I}{M}$ introduces an interface named $I$ with parent interfaces $\overline{I}$ and a suite of methods $\overline{M}$. The methods of $I$ may either override methods that are already defined in $\overline{I}$ or add new functionality special to $I$, we will illustrate this in more detail later.

The method declaration $\method{I}{m}{I_x}{x}{J}{e}$ introduces a
method named $m$ with result type $I$, parameters $\overline{x}$ of
type $\overline{I_x}$ and the overriding target $J$. The body of the
method is the single statement $ \kwreturn \; e;$. We also allow
defining abstract methods with $\absmethod{I}{m}{I_x}{x}{J}$, which is
similar to a normal method but without a method body. Notably, we have introduced the
\kwoverride{} keyword to override an old implementation of the
method. If the interface that it overrides is exactly the enclosing
interface, then such a method is seen as ``originally defined''; otherwise
it is hierarchical overriding.
For simplicity, overloading is not modelled for methods, which
implies we can uniquely identify a method by its name.\yanlin{the terminology of original methods should have been proposed in Overview.}

Expressions can be standard constructs such as variables, method
invocation, or object creation. \name{} allows two types of method invocations, one is the normal method invocation $e.m(\overline{e})$ that we are familiar with, another is the novel type of method invocation: path-invocations like ``$e.I\pathIvk m(\overline{e})$'', meaning that the dynamically bound
implementation for method $m$ should be along the path $I$. 
% Another interesting expression are super-invocations, which enable a method to access an old implementation from the specified super type. Hence a super-invocation can only be used inside an interface definition.
Finally, an expression can also be annotated with its static type. But \emph{annotated expressions are only intended for the semantic rules},
hence they are not supposed to appear in the source program. A value
``$\angl{I}\new{J}$''
is the final result of multiple reduction steps evaluating an
expression. Such value represents an object instance
of $J$ with an annotated static type $I$.

For simplicity, \name{} does not formalize statements like assignments and so on because they are orthogonal features.
A program consists of a list of interface declarations, plus a single expression.

\begin{figure*}[t]
\saveSpaceFig
\begin{displaymath}
\begin{array}{l}
\begin{array}{llrl}
\text{Interfaces}   & IL & \Coloneqq & \interface{I}{I}{M} \\
\text{Methods}      & M  & \Coloneqq & \method{I}{m}{I_x}{x}{J}{e}  \mid
									   \absmethod{I}{m}{I_x}{x}{J} \\
\text{Expressions}  & e  & \Coloneqq & x \mid
e.m(\overline{e}) \mid
\new{I} \mid \; (I)e \\
\text{Context}      & \Gamma & \Coloneqq & \overline{x}:\overline{I} \\
\text{Values}       & v & \Coloneqq & (I) \new{J} \\
%%\\
%%\text{Interface names} & I, J, K & & \\
%%\text{Method names} & m & & \\
%%\text{Variable names} & x & &
\end{array}
\end{array}
\end{displaymath}
\caption{Syntax of \name{}.}\label{fig:syntax}
\saveSpaceFig
\end{figure*}

\subsection{Subtyping and Typing Rules}
The subtyping of \MIM{} consists of only a few rules shown at the top of Figure~\ref{fig:typingrules}.
In short, subtyping relations are built from the inheritance in interface
declarations. Subtyping is both symmetric, reflexive and transitive.

Details of type-checking rules are displayed at the bottom of Figure~\ref{fig:typingrules}, including expression
typing, well-formedness of methods and interfaces. As a convention, an environment
$\Gamma$ is maintained to store the types of variables, together with
the \kwthis type, namely
the enclosing type. 
% The three rules for method invocation, \textsc{(T-Invk)}, \textsc{(T-PathInvk)} and \textsc{(T-SuperInvk)}
% are very similar, in the sense that they all check the type of the specific method, by using
% an auxiliary function \mtype. \mtype{} is the function for looking up method types, which we will
% illustrate later in Section~\ref{subsec:auxdefs}. After the method
% type is obtained, they all check that the arguments and the receiver
% have compatible types. Additionally, \textsc{(T-PathInvk)} requires the receiver to be the subtype of the specified
% path type, and \textsc{(T-SuperInvk)} checks if the enclosing type directly extends the specified super type.

There are two typing rules for method invocation: \textsc{(T-Invk)} and \textsc{(T-PathInvk)}. \textsc{(T-Invk)} is the typing judgement for a normal method invocation. First it ensures that the method receiver $e_0$ type checks to a type $I_0$. Then it checks the type of the specific method, by using an auxiliary function $\mbody(m, I_0, I_0)$, which is the function for looking up methods that we will illustrate in more detail in Section~\ref{subsec:auxdefs}. The form of \mbody is different to FJ, which has two parameters. The first $I_0$ represents the dynamic type and the second, the static type. If the result of \mbody is not \Undefined, it means the method exists and the corresponding method parameters and return types are given. After the method type is obtained, we check that all arguments $\overline{e}$ type check to $\overline{I}$ which are subtypes of $\overline{J}$. \textsc{(T-PathInvk)} is the typing judgement for a path invocation. Besides the conditions of \textsc{(T-Invk)}, \textsc{(T-PathInvk)} requires the type of receiver to be the subtype of the specified path type. 
% and \textsc{(T-SuperInvk)} checks if the enclosing type directly extends the specified super type.

\textsc{(T-New)} is the typing rule for object creation $\new{I}$. The auxiliary function $\canInstantiate(I)$ checks whether interface $I$ can be instantiated or not. If interface $I$ contains (or inherits) any abstract method that has not been implemented, then interface $I$ cannot be instantiated.

The method typing rule \textsc{(T-Method)} is more interesting since the method can either be an original implementation or hierarchical overriding.
Besides type-checking the return expression,
we further use the helper function $\mostSpecific$, again formally defined in Section~\ref{subsec:auxdefs}.
By the equation ``$\mostSpecific(m, I, J) = \{J\}$'' we define the legality of method overrides as mentioned in Section~\ref{subsec:partialoverrides}, namely if it is hierarchical overriding, it should not step over original methods, otherwise
their enclosing types would be returned instead of $J$.

\bruno{Well, there are two conditions. I suggest you explain
  in a bit more detail the 2 conditions, since this rule seems to be
  the more complex one. Some examples may help.} \yanlin{controversial rule. lets discuss later} 
Rule \textsc{(T-Intf)} defines the typing rule for interfaces. Interface $I$ type checks only if the following conditions are satisfied: 1) all methods $\overline{M}$ that are directly defined in $I$ type check; 2) method lookup $\mbody(m, I, J)$ successes as long as the method $m$ is defined in any interface $J$ which is an ancestor of $I$; 3)if an original method $m$ defined in interfaces $I$ overrides another original method defined in an ancestor of $I$, then the method types are compatible. These conditions ensure unambiguity and type soundness of the calculus. We will introduce \mbody{} and some counter-examples later. But intuitively, if $\mbody(m,I,J)$ is defined, that means $\new{I}.J::m()$ is not ambiguous during runtime. Therefore the condition says that if an expression type checks, it should not introduce ambiguity during runtime in any case. The interface check is responsible for capturing ambiguity during compilation.

\bruno{Explanation for T-Anno is missing}
Finally, rule \textsc{(T-Anno)} is the typing rule for an expression with static type annotation. The rule says that an annotated expression $\angl{J}e$ type checks to $J$ if the expression $e$ type checks and the static annotation $J$ is a subtype of $I$ which is the type of $e$.

\begin{figure*}
\saveSpaceFig
\begin{mathpar}
	\framebox{$ I <: J $} \hspace{.5in} \subid \\
	\subtrans \hspace{.5in} \subextends \\
	
	\framebox{$ \judgeewf \Gamma {e:I} $} \hspace{.5in}
	\tvar \\
	\tinvk \\
	% \tpathinvk \\
	% \tsuperinvk \\
	% \tstaticinvk  \\
	\tnew \\
	\tmethod \\
	\tabsmethod \\
	\tintf \\
	\tanno
\end{mathpar}
\saveSpaceFig
\caption{Typing and subtyping of \name{}.}
\label{fig:typingrules}
\end{figure*}

\subsection{Small-step Semantics and Congruence}
Figure~\ref{fig:smallstep} defines the small-step semantic and
congruence rules, respectively. When evaluating an expression, they
are invoked recursively and alternately to produce a single value in
the end. The small-step semantics rules \textsc{(S-Invk)} and 
\textsc{(S-PathInvk)} behave similarly: each corresponds to one kind of method invocation. \textsc{(S-PathInvk)} invokes \mbody{} for method body lookup. The parameters $\overline{x}$ are replaced with arguments $\overline{v}$ with static type annotations $\overline{\angl{I_x}}$, where $\overline{\angl{I_x}}$ is the parameter types coming from method lookup result. The rule \textsc{(S-Invk)} simply reduces the problem of normal invocation to path invocation. 

Generally, one can understand
$\mbody(m, I, J)$ in a way that it finds the most specific body of
method $m$, when the receiver has dynamic type $I$ and static type
$J$.  Notice, for example in \textsc{(S-Invk)}, that when
``$\new{I}$'' replaces ``\lstinline|this|'', its static type should be
the interface to which $m$ is dispatched. Therefore we also keep the
interface type in the definition of \mbody. 

On the other hand, there is a relationship between path invocation and
the regular method invocation, and it can be observed from the
similarity between their semantic rules in
Figure~\ref{fig:smallstep}. For any \lstinline|e.I?m()|, the result
of evaluation remains unchanged if we set the static type of
\lstinline|e| to be $I$. This can be done by an implicit cast, that
is, we can define a function with one parameter type $I$, then
\lstinline|e| is passed to that function and directly returned. This
is equivalent to writing explicit casts like \lstinline|((I) e).m()|
in languages like Java.

\begin{figure*}[t]
\saveSpaceFig
\begin{mathpar}
	% \sinvk \\
	\spathinvk \\
	% \ssuperinvk \\
	% \sstaticinvk \\
	\creceiver \hspace{.5in}
	% \cpathreceiver \\
	\cargs \\
	% \cpathargs \\
	% \csuperargs \\
	% \cstaticargs \\
	\cstatictype \\
	\cfreduce \\
	\cannoreduce
\end{mathpar}
\caption{Small-step semantics.}\label{fig:smallstep}
\saveSpaceFig
\end{figure*}

\begin{comment}
\begin{figure*}[t]
\begin{mathpar}
\end{mathpar}
\caption{Congruence.}\label{fig:congruence}
\end{figure*}
\end{comment}


\subsection{Properties}
Previously the definitions of our model are given, now we proceed to prove the type soundness of 
the model, which relates typing to computation. The type soundness states that, if an expression is 
well-typed, then after many reduction steps it must reduce to a value, with its annotation to be a subtype of the original expression type.
Following the Featherweight Java paper~\cite{Igarashi01FJ}, the type-soundness theorem 
(Theorem~\ref{theorem_soundness}) is proved by using the standard technique of subject reduction (Theorem~\ref{theorem_subject})
and progress (Theorem~\ref{theorem_progress})~\cite{Wright1994}. In Theorem~\ref{theorem_progress} ``$\#(\overline{x})$'' denotes the length of
$\overline{x}$.

\begin{theorem}[Subject Reduction]~\label{theorem_subject}
If $\judgeewf \Gamma {e : I}$ and $e \rightarrow e'$, 
then $\judgeewf \Gamma {e' : I}$.
\end{theorem}
\begin{proof}
See Appendix~\ref{appendix_proof}.
\end{proof}

\begin{theorem}[Progress]~\label{theorem_progress}
Suppose $e$ is a well-typed expression, if $e$ includes 
$\left((J)\emph{\kwnew}\;I()\right).m(\overline{v})$ as a sub-expression, then $\mbody(m, I, J) = (I_0, \overline{I_x} \; \overline{x}, I_e\; e_0)$ and $\num{\overline{x}} = \num{\overline{v}}$ for some $I_0$, $\overline{I_x}$, $\overline{x}$, $I_e$ and $e_0$.
\end{theorem}
\begin{proof}
See Appendix~\ref{appendix_proof}.
\end{proof}

\begin{theorem}[Type Soundness]~\label{theorem_soundness}
If $\judgeewf \o {e : I}$ and $e \to^* e'$ with $e'$ a normal form, then $e'$ is 
a value $v$ with $\judgeewf \o {v:I}$.
\end{theorem}
\begin{proof}
Immediate from Theorem~\ref{theorem_subject} and Theroem~\ref{theorem_progress}.
\end{proof}
