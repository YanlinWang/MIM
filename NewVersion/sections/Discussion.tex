\section{Discussion}
In this section, we will discuss the design space and reflect about some of the design decisions of our work. We relate 
our language to traits, Java interfaces as well as other languages. Furthermore we discuss
ways to improve our  work.\bruno{references please!!!}

\subsection{Abstract Methods}

Abstract methods are one of the key features in most general OO languages. For example, Java interfaces were designed
to include only method declarations, and those abstract methods can be implemented in a class body. 
The formal Featherweight Java model does not include abstract methods because of its orthogonality to the core calculus. In traits the
similar idea is to use keywords like ``\textbf{require}'' for abstract method declarations. Abstract methods provide a way to
delay the implementations to future subtypes. Using overriding, they also help to ``exclude'' existing implementations.

In our formalized calculus, however, abstract methods are not a completely orthogonal feature. The $\canInstantiate$ function
has to check whether an interface can be instantiated, by looking at all the inherited branches and seeing if each most specific method
is abstract or not.

Our formalization has a simple form of abstract methods, which behave similarly to conventional methods with respect to conflicts.
Other languages support more complicated behaviour.
For instance, in Java 8 when putting two identical abstract methods together by multiple inheritance, there is no conflict error. We omit
that case for two reasons. First, our formalization just treats abstract methods as concrete methods with an empty body, and that simplifies
the rules and the proof a lot. Second, our design choice tends to give more sense on those interesting cases, just as we reject the simple case of diamond inheritance. The triangle inheritance should distinguish and treat differently on the two methods instead of fusing them, since they represent different operations, even if they are abstract. Thus our model adopts a very conservative behaviour rather than automatically merging 
methods, and implicitly assumming diamond inheritance.

\subsection{Orthogonal \& Non-Orthogonal Extensions}\label{sec:orthoext}

Our model is designed as a minimal calculus for focusing only on resolving unintentional conflicts. Therefore, we have omitted a number of
common orthogonal features including primitive types, assignments, method overloading, covariant method return types, static dispatch, and so on.
Those features can be modularly added to the model without breaking type soundness \haoyuan{correct?}. For example, we present the additional syntax, typing and semantic rules of static invocation below as an extension:

\begin{mathpar}
	\begin{array}{llrl}
		\text{Expressions}  & e  & \Coloneqq & \ldots \; \mid \; e.J_0@J_1::m(\overline{e})
	\end{array} \\
	\tstaticinvk \\
	\sstaticinvk
\end{mathpar}
A static invocation $e.J_0@J_1::m(\overline{e})$ aims at finding the method $m$ in $J_0$ that hierarchically overrides $J_1$, thus $J_0[m\ \kwoverride\ J_1]$ is invoked. As shown in \textsc{(S-StaticInvk)}, static dispatch needs a receiver to involve in the substitution for ``$\kwthis$'' reference, so as to provide the latest implementations. In fact, static dispatch is common in OO programming, as it provides a shortcut to the reuse of old implementation easily, and super calls can also rely on this feature. For convenience we just make it simple above, whereas in languages like C++ or Java, the static or super invocations are more flexible hence complicated; they can climb the class hierarchy. 

One typical non-orthogonal extension to our model could be to have fields. Having fields in OO multiple inheritance is a non-trivial issue. There has been a lot of work on it, such as C++ that uses virtual inheritance. The trait model simply disallows state to avoid that issue. In our language, however, we can perhaps borrow the idea of \textit{interface-based programming} [], which actually models state with abstract state operations. This can be realized by extending our current model with static methods and anonymous classes from Java. To directly support fields it requires more discussions and experiments, we leave them as our future work.

\subsection{Loosening the Model}

For the goal of simplifying the model and type soundness proof, we have added a few constraints in the minimal calculus. Our language simply rejects the diamond inheritance, see the example below:

\vspace{3pt}\begin{lstlisting}
interface A { void m() {...} }
interface B extends A { void m() {...} }
interface C extends A { void m() {...} }
interface D extends B, C {}
\end{lstlisting}\vspace{3pt}
In the example, both $B.m$ and $C.m$ override $A.m$, so we think they should represent the same operation. In that case, we believe that D inherits
both conflicting methods without an explicit override, and it is in fact an intention conflict. Our calculus rejects these intentional conflicts by rule \textsc{(T-Intf)}, where $D$ is considered to be ill-formed. Nonetheless, as a general-purpose language, C++ accepts the definition of $D$, but forbids a cast from $D$ to $A$ because of ambiguity. For the conciseness of the proof, our language is more conservative on interfaces, but open on up-casts. We could also loosen the model and perform ambiguity check on casts and other expressions. We need to handle more cases than C++, for instance, in the above program assume that $B.m$ and $C.m$ are hierarchical overrides on $A$, it is still a diamond.

Another case is about the restriction on hierarchical overrides. In our language model there are two types of methods (though they share the same syntax): original methods and hierarchical overrides. We require that a hierarchical override should only override an original method. Yet from the idea of encapsulation and modularity on programs, we could also allow an override to work on another override, which forms a series of overrides.

\haoyuan{more. 1) Path Invocation, more generalized diamond inheritance: not clear; other method resolution techniques: no example; better code reuse with other kinds of method invocation: no example. }
