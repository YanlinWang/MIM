\section{Formalization}~\label{sec:formalization}

In this section, we present a formalization of our \MIM{} calculus, based on
a minimal subset of Java 8 interfaces following Featherweight Java style~\cite{Igarashi01FJ}.
The syntax, typing rules and small-step
semantics are included below.

\subsection{Syntax}

Figure~\ref{fig:syntax} shows the syntax of \MIM{}. The multiple
inheritance feature of \MIM{} as a basis Java 8 interfaces, which support
method implementations via default methods. This feature is quite
closely related to \emph{traits}\cite{scharli03traits}.  To demonstrate how
unintentional method conflicts are untangled in \MIM{}, we present the
calculus in a straightforward way, hence we only focus on a small
subset of the interface model. For example, all the methods declared
in an interface are default methods, that is to say, they always
provide default implementations.  From this point we can view that we
are actually modelling a class model that supports multiple
inheritance. Then it is straightforward to do object creation like
$\new I$. Fields and primitive types are not modelled as well.

We use uppercase letters like $I, J, K$ to represent identifiers for
interfaces. By multiple inheritance, an interface can have a set of
super interfaces, where such a set can be empty. Inside an interface
is a set of method declarations. Each method body holds a return
statement. As seen in Figure~\ref{fig:syntax}, we have introduced the
\kwoverride{} keyword to override an old implementation of the
method. If the interface that it overrides is exactly the enclosing
interface, then such a method is seen as ``originally defined''; otherwise
it is a partial override.
Again for simplicity, overloading is not modelled for methods, which
implies we can uniquely identify a method by its name.

An expression can be a variable, a method invocation, an object
creation, furthermore, a path-invocation like
``$e.I::m(\overline{e})$'', meaning that the dynamically binded
implementation for method $m$ should be along the path $I$. Another
case is the super-invocation, enabling a method to access an old
implementation from the specified super type. Hence a super-invocation
can only be used inside an interface definition.
Finally an expression can also be annotated with its static type. But annotated expressions are only intended for the semantic rules,
hence they are not supposed to appear in the source program. A value is the final result of semantic
rules on evaluating an expression, which looks like ``$<I> \new J$''. It is exactly an object instance
of $J$ with annotated static type $I$.


\begin{figure*}[t]
\begin{displaymath}
\begin{array}{l}
\begin{array}{llrl}
\text{Interfaces}   & IL & \Coloneqq & \interface{I}{I}{M} \\
\text{Methods}      & M  & \Coloneqq & \method{I}{m}{I_x}{x}{J}{e} \\
\text{Expressions}  & e  & \Coloneqq & x \mid
e.m(\overline{e}) \mid
\new{I} \mid
e.I::m(\overline{e}) \mid
\kwsuper.I::m(e) \; \mid \; <I> e \\
\text{Context}      & \Gamma & \Coloneqq & \overline{x:I} \\
\text{Values}       & v & \Coloneqq & <I>\new{J} \\
\\
\text{Interface names} & I, J, K & & \\
\text{Method names} & m & & \\
\text{Variable names} & x & &
\end{array}
\end{array}
\end{displaymath}
\caption{Syntax.}\label{fig:syntax}
\end{figure*}

\subsection{Subtyping and Typing Rules}
The subtyping of \MIM{} consists of only a few rules shown in Figure~\ref{fig:subtyping}.
In short, subtyping relations are built from the inheritance in interface
declarations. They hold both reflexivity and transitivity.

Details of type-checking rules are displayed in Figure~\ref{fig:typingrules}, including expression
typing, well-formedness of methods and interfaces. As a convention, an environment
$\Gamma$ is maintained to store the types of variables, together with ``this'' type, namely
the enclosing type. The three rules for method invocation, \textsc{(T-Invk)}, \textsc{(T-PathInvk)} and \textsc{(T-SuperInvk)}
are very similar, in the sense that they all check the type of the specific method, by using
an auxiliary function \mtype. \mtype{} is the function for looking up method types, which we will
illustrate later in Section~\ref{subsec:auxdefs}. After the method type is obtained, they all check that arguments and the receiver
have compatible types. Additionally, \textsc{(T-PathInvk)} requires the receiver to be the subtype of the specified
path type, and \textsc{(T-SuperInvk)} checks if the enclosing type directly extends the specified super type.

The method typing rule \textsc{(T-Method)} is more interesting, since the method can either be an original implementation or a partial override.
Besides static type-checking for the return expression,
we further use the helper function $\mostSpecific$ to ensure that the method update is legal. The formal definition is again in Section~\ref{subsec:auxdefs}.
By the equation ``$\mostSpecific(m, I, J) = \{J\}$'' we define the legality of method overrides as mentioned in Section~\ref{subsec:partialoverrides}, namely if it is a partial override, it should not overlap a total override, otherwise
the total override would be returned instead of $J$.

Finally, \textsc{(T-Invk)} defines interface checking. The condition helps to ensure unambiguity and type soundness of the calculus. We will
introduce \mbody{} and some counter-examples later. But intuitively, if $\mbody(m,I,J)$ is defined, that means $\new{I}.J::m()$ is not
ambiguous during runtime. Therefore the condition says that if an expression type checks, it should not introduce ambiguity during runtime
in any case. The interface check is responsible to capture ambiguity during compilation.

\begin{figure*}[t]
\begin{mathpar}
	\framebox{$ I <: J $} \hspace{.5in} \subid \\
	\subtrans \hspace{.5in} \subextends
\end{mathpar}
\caption{Subtyping.}\label{fig:subtyping}
\end{figure*}


\begin{figure*}[t]
\begin{mathpar}
	\framebox{$ \judgeewf \Gamma {e:I} $} \hspace{.5in}
	\tvar \\
	\tinvk \\
	\tpathinvk \\
	\tsuperinvk \\
	\tnew \\
	\tmethod \\
	\tintf
\end{mathpar}
\caption{Typing rules.}\label{fig:typingrules}
\end{figure*}

\subsection{Small-step Semantics and Congruence}
Figure~\ref{fig:smallstep} and Figure~\ref{fig:congruence} define small-step semantic rules and congruence rules,
respectively. When evaluating an expression, they are invoked recursively and
alternately to produce a single value in the end. The small-step semantics \textsc{(S-Invk)}, \textsc{(S-PathInvk)} and \textsc{(S-SuperInvk)} behave similarly, each corresponds to
one kind of method invocation. They all invoke \mbody{} for method body lookup. Generally, one can understand $\mbody(m, I, J)$ in a way that it finds the most specific body of method $m$, when the receiver has dynamic type $I$ and static type $J$.
Notice, for example in \textsc{(S-Invk)}, that when ``$\new{I}$'' replaces ``\lstinline|this|'', its static type should be the interface to which $m$ is dispatched. Therefore we also keep the interface type in the definition of \mbody. This point is consistent with the last paragraph in
Section~\ref{subsec:solutionmim}.

On the other hand, there is a relationship between path invocation and the regular method invocation, and it can be observed from the similarity
between their semantic rules in Figure~\ref{fig:smallstep}. For any \lstinline|e.I::m()|, the result of evaluation remains unchanged if we set the static type of \lstinline|e| to be $I$. This can be done by an implicit cast, that is, we can define a function with one parameter type $I$, then \lstinline|e| is passed to that function and directly returned. It is just equivalent if we write explicit casts like \lstinline|((I) e).m()| in languages like Java.

\begin{figure*}[t]
\begin{mathpar}
	\sinvk \\
	\spathinvk \\
	\ssuperinvk
\end{mathpar}
\caption{Small-step semantics.}\label{fig:smallstep}
\end{figure*}


\begin{figure*}[t]
\begin{mathpar}
	\creceiver \hspace{.5in}
	\cpathreceiver \\
	\cargs \\
	\cpathargs \\
	\csuperargs \\
	\cstatictype \\
	\cfreduce \\
	\cannoreduce
\end{mathpar}
\caption{Congruence.}\label{fig:congruence}
\end{figure*}



\subsection{Auxiliary Definitions}\label{subsec:auxdefs}

To make our formalization concise and expressive, we have defined a list of
auxiliary functions, collected by Figure~\ref{fig:auxfunc}. To begin with, we
introduce the basic functions: $\ext, \overrideSet$ and $\prune$. $\ext(I, J)$
simply indicates that interface $I$ directly extends interface $J$. Compared to
to this is a more general case $I <: J$, meaning that $I$ is a subtype of $J$.
$\overrideSet(I, J)$ returns a set of methods defined in $I$ that have ``$\kwoverride \; J$''
in their signatures. Notice that $\overrideSet(I, I)$ is a special representative of
the ``originally-defined'' method set from $I$. The $\prune$ function takes a set of
types, and filters out those that have subtypes in the same set. Finally in the returned set,
none of them has a subtyping to one another, since all super types have been removed.

\begin{figure*}[t]
	\begin{mathpar}
	\inferrule* [left=]
		{  \mostSpecific(m, I_d, I_s) = \{I\} \\
			\mostSpecificOverride(m, I_d, I) = \{J\} \\
			\kwinterface \; J \; \kwextends \; \overline{J} \; \{\method{I_E}{m}{I_X}{x}{I}{e_0}\ldots\}}
		{\mbody(m, I_d, I_s) = (J, \overline{I_X} \; \overline{x}, I_E \; e_0)}
	
	\inferrule* [left=]
	{ set1 = \; \{ K <: J \; $and$ \; K >: I \; | \; m \in \overrideSet(K, K) \} \\
		set2 = \; \{ K >: J \; | \; m \in \overrideSet(K, K) \} }
	{\mostSpecific(m, I, J) = \left\{{\begin{tabular}{ll}
				$prune(set1)$ & if $set1$ is not empty \\ $prune(set2)$ & otherwise
			\end{tabular}}\right.}
	
	\inferrule* [left=]
		{ set = \; \{ K <: J \; $and$ \; K >: I \; | \;
			m \in \overrideSet(K, J)  \} }
		{\mostSpecificOverride(m, I, J) = prune(set)}
	
	prune(set) = \{I \in set \; | \; \nexists J \in set, J <: I, J \neq I \}
	
	\inferrule* [left=]
	{   \interface{I}{I}{M}
		\\ J \in \overline{I} }
	{\ext(I, J)}
	
	\inferrule* [left=]
	{   \kwinterface \; I \; \kwextends \; \overline{I} \; \{ I_E \; m(\overline{I_X} \; \overline{x}) \;
		\kwoverride \; J \ldots \} }
	{m \in \overrideSet(I, J)}
	\end{mathpar}
	\caption{Auxiliary functions.}\label{fig:auxfunc}
\end{figure*}

\begin{figure*}[t]
	\centering
	\vspace{-1ex}
	\begin{tabular}{ccc}
		\includegraphics[width=2cm]{pics/p1.pdf}\hspace{4pt} &
		\includegraphics[width=2cm]{pics/p2.pdf}\hspace{4pt} &
		\includegraphics[width=2cm]{pics/p3.pdf}\hspace{4pt} \\
		(a) $\mbody(m,C,A) = (A,...)$\ \ \  & (b) $\mbody(m,C,A) = (C,...)$\ \ \  & (c) $\mbody(m,C,A) = (C,...)$
	\end{tabular} \\
   \begin{tabular}{cc}
   	\includegraphics[height=3cm]{pics/p4.pdf}\hspace{4pt} &
   	\includegraphics[height=3cm]{pics/p5.pdf}\hspace{4pt} \\ 
   	(d) $\mbody(m,D,A) = \keyword{undefined}$\ \ \  & (e) $\mbody(m,D,A) = \keyword{undefined}$
   \end{tabular}
	\caption{Examples on $\mbody$.}\label{fig:examplesmbody}
	%\saveSpaceFig
\end{figure*}

\subsubsection{$\mostSpecific$ and $\mostSpecificOverride$}

$\mostSpecific$ is an auxiliary function that finds the most specific original implementations of a method. Let us consider $\mostSpecific(m, I, J)$, what it returns is a set of interfaces, each including its own $m$ as a most specific implementation. Such a set may contain several elements, but that implies ambiguity; what we expect is actually a singleton set. By the definition of $\mostSpecific$ shown in Figure~\ref{fig:auxfunc}, an interface belongs to the return set if and only if:
\begin{itemize}
	\item It has an original definition of $m$;
	\item It is a supertype of $I$;
	\item It is along path $J$, meaning that it is either a supertype or a subtype of $J$ (including $J$ itself);
	\item It does not have a subtype in the same set, because we have used $prune$ to filter out all super types.
\end{itemize}
We could have put $set1$ and $set2$ together, but the current definition leads a clearer illustration.

The $\mostSpecific$ function only focuses on original method implementations, all the method updates are omitted during that time. On the other hand, another auxiliary function $\mostSpecificOverride(m, I, J)$ has the assumption that $J$ defines an original $m$, and this function tries to find the most specific implementations that partially overrides such an $m$. Just as $\mostSpecific$, $\mostSpecificOverride$ also returns the set of interfaces after pruning. An interface belongs to the return set if and only if:
\begin{itemize}
	\item It is between $I$ and $J$;
	\item It defines a method update for $J.m$;
	\item It does not have a subtype in the same set.
\end{itemize}
The algorithm for finding the most specific partial overrides is quite similar to that for most specific original method. A partial override is not allowed to work on another partial override, and one can hide another if their interfaces has subtyping relations. If they do not hide each other, the result implies ambiguity.

\subsubsection{$\mbody$ and $\mtype$}

$\mbody(m, I_d, I_s)$, as defined in Figure~\ref{fig:auxfunc}, denotes a method body lookup function.
We use $I_d, I_s$, since $\mbody$ is usually invoked by a receiver of a method $m$, with its dynamic
type $I_d$ and static type $I_s$. Such a function returns the most specific method implementation, more
accurately, its parameters, returned expression and the types. It considers both originally defined methods and method updates, so $\mostSpecific$ and $\mostSpecificOverride$ are invoked.

To calculate $\mbody(m, I_d, I_s)$:
\begin{itemize}
	\item First, it invokes $\mostSpecific(m, I_d, I_s)$ and returns a set.
	\item If $\mostSpecific$ returns a singleton set $\{I\}$, then it is good, otherwise $\mbody$ is undefined in
	this case. The set $\{I\}$ implies that we will use the $m$ from $I$ without ambiguity. But moreover, we have to invoke $\mostSpecificOverride(m, I_d, I)$, to check if there are updated versions of $m$ between $I_d$ and $I$. Again we forbid ambiguity, so the expected set after pruning is also a singleton set $\{J\}$.
	\item Finally, we fetch the implementation of $m$ in interface $J$ and return its related information.
\end{itemize}
The definition of $\mtype$ used in typing rules simply relies on $\mbody$. In short,
$$\mbody(m, I, I) = (J, \overline{I_x}\ \overline{x}, I_E\ e) \ \Longrightarrow\ \mtype(m, I) = \overline{I_x}\rightarrow I_E$$

\begin{comment}
$mbody(m, I)$ algorithm:
\begin{itemize}
	\item If m is defined in I directly, then return I.m()
	\item Else, let $\overline{I'} = mdefined(fathers(I))$, all ancestors of $I$ that has directly defined $m()$.
	\item $\overline{I''} = needed(\overline{I'})$, keep only interfaces that are needed, which are not super-interface of others.
	\item If $\overline{I''}$ is unique, then return this unique one. Else if any two I1,I2 in $\overline{I''}$ share a parent in $\overline{I'}$, then diamond conflict is detected, report error. Else return multiple $m()$s.
\end{itemize}
\end{comment}

\begin{comment}
\subsubsection{\collectMethods}
\[ \collectMethods(I) = \left( \bigcup_{I_i \in \overline{I}} \methods(I_i) \right) \bigcup \methods(I) \]
\[ \methods(I) = \overline{M}, \text{where } IT(I) = \interface{I}{I}{M} \]
\end{comment}

\subsubsection{Examples}

Examples on $\mbody$ are shown in Figure~\ref{fig:examplesmbody} for a better understanding. For each small example, the result
gives the interface to which $m$ is dispatched. (a) is a basic model for unintended method conflicts; (b) and (c) demonstrate
that hierarchical dispatch can find the most specific original method and partial override. More interesting are the two bad examples
(d) and (e), they both fail on $\mbody$. (d) is the well-known diamond inheritance, which our model also forbids, and (e) is similar to
(d) because the two partial overrides are working on the same operation. Both counter-examples imply that \lstinline|new D().A::m()| will
lead to ambiguity, and in order for type soundness, both have to be denied by the type checker. It has been guaranteed by the interface check
\textsc{(T-Intf)} in Figure~\ref{fig:typingrules}.

\subsection{Properties}
Previously the definitions of our model are given, now we should proceed to prove the type soundness of 
the model, which relates typing to computation. The type soundness states that, if an expression is 
well-typed, then after many reduction steps it must reduce to a value, with its annotation to be subtype of the original expression type.
Following the FeatherweightJava paper~\cite{Igarashi01FJ}, the type-soundness theorem 
(Theorem~\ref{theorem_soundness}) is proved by using the standard technique of subject reduction (Theorem~\ref{theorem_subject})
and progress (Theorem~\ref{theorem_progress})~\cite{Wright1994}. In Theorem~\ref{theorem_progress} ``$\#(\overline{x})$'' denotes the number of
elements.

\begin{theorem}[Subject Reduction]~\label{theorem_subject}
$\textit{If } \ \judgeewf \Gamma {e : I} \; \textit{ and } \ e \rightarrow e',\ 
\textit{then } \judgeewf \Gamma {e' : I'} \ \textit{ for some } \ I' <: I.$
\end{theorem}
\begin{proof}
See Appendix~\ref{appendix_proof}.
\end{proof}

\begin{theorem}[Progress]~\label{theorem_progress}
$\textit{Suppose } e \textit{ is a well-typed expression } $ \\
\begin{enumerate}
\item If $e$ includes $\left(<J>\emph{\kwnew}\;I()\right).m(\overline{<I_E>} \; \overline{e})$ as a subexpression,
    then $ \emph{\mbody}(m, I, J) = (J', \overline{I_X} \; \overline{x}, I'_E \; e_0) $ and
         $\num{\overline{x}} = \num{\overline{e}}$ for some $\overline{I_X}, \overline{x}, I_E'$ and $e_0$.
\item If $e$ includes $\left(<J>\emph{\kwnew}\;I()\right).K::m(\overline{<I_E> e})$ as a subexpression,
    then $ \emph{\mbody}(m, I, K) = (J', \overline{I_X} \; \overline{x}, I'_E \; e_0) $ and 
         $\num{\overline{x}} = \num{\overline{e}}$ for some $\overline{I_X}, \overline{x}, I_E'$ and $e_0$.
\item If $e$ includes $\emph{\kwsuper}.K::m(\overline{<I_E> e})$ as a subexpression,
    then $ \emph{\mbody}(m, K, K) = (J', \overline{I_X} \; \overline{x}, I'_E \; e_0) $ and 
         $\num{\overline{x}} = \num{\overline{e}}$ for some $\overline{I_X}, \overline{x}, I_E'$ and $e_0$.
\end{enumerate}
\end{theorem}
\begin{proof}
See Appendix~\ref{appendix_proof}.
\end{proof}

\begin{theorem}[Type Soundness]~\label{theorem_soundness}
If $\judgeewf \o {e : I}$ and $e \to^* e'$ with $e'$ a normal form, then $e'$ is 
a value $v$ with $\judgeewf \o {v:J}$ and $J \subtype I$.
\end{theorem}
\begin{proof}
Immediate from Theorem~\ref{theorem_subject} and Theroem~\ref{theorem_progress}.
\end{proof}
