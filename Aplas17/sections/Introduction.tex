\section{Introduction}
\bruno{Please fill in the references.}
Inheritance in Object-Oriented Programming (OOP) offers a mechanism
for code reuse. However many OOP languages are restricted to single
inheritance, which is less expressive and flexible than multiple
inheritance. Nevertheless different flavours of multiple inheritance
have been adopted in some popular OOP languages. C++ has had 
multiple inheritance from the start. Scala adapts ideas from traits~\cite{scharli03traits} 
and mixins~\cite{bracha90mixin} to offer a disciplined form of multiple inheritance. Java 8 
offers a variant of traits with disguised of interfaces with default methods~\cite{goetz12fdefenders}.

A reason why programming languages have resisted to multiple
inheritance in the past is that, as Cook~\cite{Cook1987} puts it, 
multiple inheritance is good but ``\emph{there is no good way to do it}''.
One of the most sensitive and critical issues is perhaps the ambiguity
introduced by multiple inheritance. One case is the famous
\textit{diamond problem}~\cite{Sak89dis,Singh1995}. In the diamond problem inheritance could allow
one feature to be inherited from multiple parent classes, hence
conflicts arise. The variety of strategies on resolving such conflicts
urges the occurrence of different multiple inheritance models,
including traits, mixins, CZ~\cite{malayeri2009cz}, and many others. Existing
languages have taken care of this case intensively. Other issues
include how multiple inheritance deals with state, as discussed in
which also has been discussed quite extensively~\cite{classless, C++,...}.

In contrast with the diamond inheritance, a second case of ambiguity
is \textit{unintentional method conflicts}~\cite{scharli03traits}. That is conflicting 
methods that do not actually refer to the same feature.
%%This issue was proposed by the trait paper, so-called
In a nominal system, methods can be designed for different
functionality, but they just happen to have same names (and
signatures). When inheritance is used to compose those methods an
error happens due to conflicts. However, unlike the diamond problem,
the conflicted methods usually do not share a common parent. In this
paper we call such a case ``\textit{triangle inheritance}''.
\haoyuan{Fine to have a graph with diamond and triangle shapes if we got space.}

Unintentional method conflicts are less common than the diamond
problem, nonetheless, they have severe effects in practice. This is
unfortunate because such an issue has not received much formal study 
before. In practice existing languages also provide limited support for
it. In most languages, the mechanism available to deal with this problem are the same as the diamond
inheritance. Unfortunatelly this is often inadequate and can lead 
to tricky problems in practice. This is especially the case
when it is necessary to combine two large modules and their features,
but the inheritance is simply prohibited by a small conflict. As
a workaround from the diamond inheritance side, it is possible to
define a new method in the child class, to override those conflicting
methods. Intuitively using one method to fuse two unrelated features
is unsatisfactory. Therefore we need a real solution to keep both
features separately during inheritance, so as not to break
\emph{independent extensibility}\cite{zenger05independentlyextensible}.

Some other workarounds or approaches include delegation, and
renaming/exclusion in the trait model. Yet they still have various
drawbacks as we will discuss in Section~\ref{sec:overview}. Closest to our work
are mechanisms available in C++ and C\# that allow for two
unintentionally conflicted method to coexist in the system. Among them
C++ is a representative that accepts the triangle inheritance and
resolves the ambiguity by \emph{static dispatching}. However, C++ has
limited support for virtual methods with unintentional conflicts, and
it will often throw errors when composing them. This is again
unsatisfactory because virtual methods are pervasive in OOP and used 
for code reuse and extensibility.

Having tolerance for unintentional method conflicts does not mean to
sacrifice extensibility, hence in contrast with static dispatch and
dynamic dispatch, we propose a third approach, which looks like a
combination of both, called \textit{hierarchical dispatch}. By
hierarchical dispatch, the method binder will look at both the \emph{static
type} and the \emph{dynamic type} of the receiver during runtime. When there
are multiple branches that cause unintentional conflicts, the static
type can specify one branch among them for unambiguity, and the
dynamic type helps to find the most specific (the newest)
implementation. In that case both unambiguity and extensibility are
preserved. To present this idea, we introduce a formalized model in
Section~\ref{sec:formalization} based on Featherweight Java~\cite{Igarashi01FJ}, together with theorems and
proofs for type soundness. In the model we also propose
\textit{partial overrides}, where a method refinement can be applied
only to one branch. Our model generalizes the trait
model by providing additional support to the triangle inheritance.

In summary, our contributions are: \haoyuan{will have prototype implementation in Scala if we still have time.}
\begin{itemize}
	\item \textbf{Hierarchical dispatch:} which integrates both the static type and dynamic type for method dispatch, and hence
	ensures unambiguity as well as extensibility.
	\item \textbf{Partial overrides:} a novel notion that allows method refinements on individual branches.
	\item \textbf{MIM:} a formalized model based on Featherweight Java, supporting the above features. Some theorems and their proofs
	are attached to confirm the type soundness (unambiguity?) of the model.
\end{itemize}

 