\section{A Running Example: DrawableDeck}

This section illustrates the features of our \MIM{} model for resolving unintentional method
conflicts. As mentioned before, such a case arises when two inherited methods happen to have the
same signature, but with different semantics and functionalities. This could be quite troublesome
to programmers that use multiple inheritance. Below we illustrate with a running example called \lstinline|DrawableDeck|.
Note that we use Java-like syntax throughout the paper, and all types are defined with the keyword ``\lstinline|interface|'', which
supports multiple inheritance. Since \MIM{} is designed to be simple, we do not allow abstract methods, that is every method
is required to have a body for its implementation. In that case, interfaces can be directly instantiated by the keyword ``\lstinline|new|''
to create an object.

\subsection{Problem: Unintentional Method Conflicts}

Suppose that two components \lstinline|Drawable| and \lstinline|Deck| have been developed in a system.
\lstinline|Drawable| defines an interface for graphics that can be drawn, which includes a method called \lstinline|draw()|
for visual display. While interface \lstinline|Deck| represents a deck of cards, and supports several operations, like
\lstinline|draw()| for drawing a card from the deck.

\begin{lstlisting}
interface Deck {
  void draw() { // draws a card from the Deck
    Stack<Card> cards = this.getStack();
    Card card = cards.pop();
    ...
  }
}

interface Drawable {
  void draw() { // draws something on the screen
    JFrame frame = new JFrame("Canvas");
    frame.setVisible(true);
    ...
  }
}
\end{lstlisting}
Note that both methods have \lstinline|void| return type (we will not formalize
\lstinline|void| in our calculus afterwards; here is only for illustration). In \lstinline|Deck|, \lstinline|draw()| tries to get the cards as a stack, pops
out the top card, and so on. While in \lstinline|Drawable|, \lstinline|draw()|
creates a blank canvas using \lstinline|JFrame|. Now, a programmer is designing a
card game with GUI. He may want to draw a deck on the screen, so he defines a drawable
deck using multiple inheritance:

\begin{lstlisting}
interface DrawableDeck extends Deck, Drawable {
  ...
} 
\end{lstlisting}
The point of using multiple inheritance is surely for composing the features of
components, achieving great code reuse. It is supported by many mainstream OO
languages. Nevertheless at this point, \lstinline|DrawableDeck| has to throw a compile
error, for the two \lstinline|draw()| methods cause a conflict, though accidentally.

\subsection{Potential fixes}

For that problem, there are several workarounds that quickly come to our mind:

\paragraph{I. Delegation.} As an alternative to multiple inheritance, delegation can be used by
introducing two fields with \lstinline|Drawable| type and \lstinline|Deck| type, respectively. This avoids
method conflicts, nevertheless, delegation itself is too restricted in modularity, and meanwhile
introduces a lot of boilerplate.

\paragraph{II. Creating a \lstinline|draw()| method in \lstinline|DrawableDeck|, which explicitly overrides the old ones.}
This is a non-solution. It does not make any sense to override both methods with totally different functionalities, as old
methods have to be hidden.

\paragraph{III. Choosing one of them as the default method, like Mixins.} The mixin model can be applied to choose a
default one based on linearisation. Similarly, we want to preserve both features, rather than keeping only one of them.

\paragraph{IV. Method exclusion like traits.} Same reason as above.

\paragraph{V. Method renaming like traits.} This is probably what people do in most cases, by simply renaming one to avoid conflicts.
It can indeed preserve both features, however, it is cumbersome in practice, as introducing new names can affect other code blocks.
Certainly this is a workaround, not a solution.

\subsection{Solution in \MIM: \dispatchnamecaptical}
It uses dynamic dispatch.

\subsection{Method refinement}

