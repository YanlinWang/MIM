\section{Overview}
\subsection{Motivation}
Combine the work of FHJ and ClasslessJava.
\begin{itemize}
	\item Use abstract state operations to mimic state
	\item If two fields conflict from triangle inheritance, keep the two fields
	\item Override and covariant type refine of fields
\end{itemize}

Example of unintentional fields confliction:
\begin{lstlisting}
interface Payment {
	String Check(); // represnets an entity 'check'
}
interface Verify {
	boolean Check(); // represents a flag of whether the verification is checked or not.
}
interface VerifiedPayment extends Payment, Verify {}
\end{lstlisting}

C++ partly support this, just like unintentional method conflicts. However, c++ cannot handle the case where fields need to be refined or two conflicted fields need to be merged.
\begin{lstlisting}
class A {};
class B:A {};
class Payment {
	public:
	A* check;
};
class Verify {
	public:
	bool check;
};
class VerifiedPayment : public Payment, public Verify {
	public:
	B* check;
};

int main()
{
VerifiedPayment* vp = new VerifiedPayment();
vp->check = new B();
vp->Verify::check = true;
vp->check;
cout << vp->Payment::check << endl;
cout << vp->check << endl;
}
\end{lstlisting}


Example program in a desired language:
\begin{lstlisting}
interface A { int x(); int y(); }
interface B { int x(); }
interface C extends A, B {}
new B(B.x = 0).GET_x();   // 0
(A)new C(A.x = 1, A.y = 2, B.x = 3).GET_x();  // 1
\end{lstlisting}

\section{Formalization}~\label{sec:formalization}
This version:
\begin{itemize}
	\item does not support fluent setters
	\item let-expressions
	\item explicit constructor.
\end{itemize}
\begin{figure*}
	\saveSpaceFig
	\begin{displaymath}
		\begin{array}{l}
			\begin{array}{llrl}
				\text{Program}		& P & \Coloneqq  & \overline{IL} \ e  \\
				\text{Interfaces}   & IL & \Coloneqq & \interfaceMC{I}{I}{MC?}{M} \\
				\text{Constructors} & MC & \Coloneqq & \constructor{I_x}{J.x} \\
				\text{Methods}      & M  & \Coloneqq & \method{I}{m}{I_x}{x}{J}{e}  \mid
													   \absmethod{I}{m}{I_x}{x}{J} \\
				\text{Expressions}  & e  & \Coloneqq & 
				x \mid
				e.m(\overline{e}) \mid
				(I)e \mid 
				\kwnew \; I(\overline{e}) \mid 
				\mylet{I}{x}{e_1}{e_2} \\
				\text{Context}      & \Gamma & \Coloneqq & \overline{x}:\overline{I} \\
				\text{Values}       & v & \Coloneqq & (I)o \\
			\end{array}
		\end{array}
	\end{displaymath}
	\caption{Syntax}\label{fig:syntax}
	\saveSpaceFig
\end{figure*}

%\begin{figure*}[]
%	\saveSpaceFig
%	\begin{mathpar}
%		\framebox{$ I <: J $} \hspace{.5in} \subid \\
%		\subtrans \hspace{.5in} \subextends \\
%		
%		\framebox{$ \judgeewf \Gamma {e:I} $} \hspace{.5in}
%		\tvar \\
%		\tinvk \\
%		% \tpathinvk \\
%		% \tsuperinvk \\
%		% \tstaticinvk  \\
%		\tnew \\
%		\tanno \\
%		\tmethod \\
%		\tabsmethod \\
%		\tintf
%	\end{mathpar}
%	\saveSpaceFig
%	\caption{Subtyping and Typing Rules}
%		\label{fig:typingrules}
%	\end{figure*}
	
\begin{figure}
	\begin{mathpar}
		\inferrule* [left=(T-Var)]
		{\judgeewf {} {\Delta \; OK} \\ \judgeewf \Delta {\Gamma \; OK} }
		{\judgeewf {\Delta; \Gamma, x:I}{x:I}}
		
		\inferrule* [left=(T-Invk)]
		{  \judgeewf {\Delta; \Gamma} {e_0:I_0}
			\\ \mbody(m, I_0, I_0) = (K, \overline{I_x} \; \overline{x}, I \; \_) 
			\\ \judgeewf {\Delta; \Gamma} \overline{e}:\overline{I}
			\\ \overline{I} \subtype \overline{I_x}
		}
		{\judgeewf {\Delta, \Gamma} e_0.m(\overline{e}):I} 
		
		\inferrule* [left=(T-Constructor)]
		{  \mconstr(I_0) = \overline{I_x} \; \overline{x} 
			\\ \judgeewf {\Delta; \Gamma} \overline{e}:\overline{I}
			\\ \overline{I} \subtype \overline{I_x}
		}
		{\judgeewf {\Delta, \Gamma} \newI{I_0}{\overline{e}}:I_0} 
		
		\inferrule* [left=(T-Cast)]
		{  \judgeewf {\Delta, \Gamma}\Gamma e:I  \\
			I \subtype J  }
		{ \judgeewf {\Delta, \Gamma} {(J)e : J} }
		
		\inferrule* [left=(T-Method)]
		{  I <: J \\
				\mostSpecific(m, I, J) = \{J\} \\
				\mbody(m, J, J) = (K, \overline{I_x} \; \overline{x}, I_e \; \_) \\
				\judgeewf {\Delta; \Gamma, \overline{x}:\overline{I_x}, this:I  } {e_0:I_0} \\
				I_0 \subtype I_e
		}
		{\method{I_e}{m}{I_x}{x}{J}{e_0} \text{ OK IN } I}
	
		\inferrule* [left=(T-AbsMethod)]
		{  I <: J \quad
			\mostSpecific(m, I, J) = \{J\} \\
			\mbody(m, J, J) = (K, \overline{I_x} \; \overline{x}, I_e \; \_)
		}
		{\absmethod{I_e}{m}{I_x}{x}{J} \text{ OK IN } I}
		
		\inferrule* [left=(T-MC)]
		{  \validMC(I, \overline{I_x}, \overline{J.x}) 
		}
		{\constructor{I_x}{J.x} \text{ OK IN } I}
		
		
		\inferrule* [left=(T-Intf)]
		{  MC \text{ OK IN }  I \\
			\overline{M} \text{ OK IN } I \\
			\forall J >: I \text{ and } m, \mbody(m, J, J) \text{ is defined} \Rightarrow \mbody(m, I, J) \text{ is defined} \\ 
			\forall J >: I \text{ and } m, I[m \; \kwoverride \; I] \text{ and } J[m \; \kwoverride \; J] \text{ defined}  \Rightarrow \canOverride(m, I, J)
		}
		{ \interfaceMC{I}{I}{MC?}{M} \text{ OK }}
		
		\inferrule* [left=(T-Prog)]
		{  \forall I \in \overline{IL}, I \text{ OK} \\
		   \judgeewf {\Delta; \Gamma} {e : T}
		}
		{ \prog{IL}{e} \text{ OK }}

		\inferrule* [left=(T-Let)]
		{  	\judgeewf {\Delta; \Gamma} {e_1:I_1} \\
			I_1 \subtype I \\	
			\judgeewf {\Delta; \Gamma, x:I} {e_2:I_2} 
		}
		{ 	\judgeewf {\Delta; \Gamma} {\mylet{I}{x}{e_1}{e_2}:I_2} }
		
		\end{mathpar}
	\caption{Typing Rules.}
\end{figure}

	
\begin{figure}
\begin{flushleft}
	\begin{mathpar}		
		\inferrule* [left=(E-Invk)]
		{ }{\mu \mid (J)o.m(\overline{v}) \to \mu \mid e'} \\
		\mu(o) = \newI{I}{...} \\ 
		\mbody(m, I, J) = \overline{I_x} \ \overline{x}, e \\ 
		e' = e[(J)o/\kwthis, (\overline{I_x})\overline{v}/\overline{x}] \\

		\inferrule* [left=(E-New)]
		{ }{\mu \mid \newI{I}{\overline{v}} \to \mu' \mid (I)o} \\
		o \notin dom(\mu) \\
		\mu' = \mu, o \to \newI{I}{\overline{v}} \\

		\inferrule* [left=(E-Getter)] 
		{ }{\mu \mid (J)o.f() \to \mu \mid (I_F)o_i} \\
		\mu(o) = \newI{I}{o_1, ..., o_n} \\
		I_F \; J.f \textit{ is the i-th element of } \newI{I}{...} \\

		\inferrule* [left=(E-Setter)]
		{ }{\mu \mid (J)o.SET\_f((I')o) \to \mu' \mid (I)o} \\
		\mu(o) = \newI{I}{o_1, ..., o_n} \\
		J.f \textit{ is the i-th element of } \newI{I}{...} \\
		\mu = \mu'', o \to \newI{I}{o_1, ..., o_i, ..., o_n} \\
		\mu' = \mu'', o \to \newI{I}{o_1, ..., o', ..., o_n} \\

		\inferrule* [left=(E-Let)]
		{ }{\mu \mid \mylet{I}{x}{o}{e} \to \mu \mid e[(I)o/x]} \\

		\inferrule* [left=(E-Cast)]
		{ }{\mu \mid (J)((I)o) \to \mu \mid (J)o} \\

		\inferrule* [left=(E-CTX)]
		{\mu \mid e \to \mu' \mid e'}
		{\mu \mid \varepsilon\{e\} \to \mu' \mid \varepsilon\{e'\}} \\

		\varepsilon ::= \varepsilon.m(\overline{e}) \mid 
				     (J)o.m(\overline{o}, \varepsilon, \overline{e}) \mid
				     \newI{I}{\overline{o}, \varepsilon, \overline{e}} \mid
				     \mylet{I}{x}{\varepsilon}{e} \mid
				     (I)\varepsilon
		\end{mathpar}
\end{flushleft}
\caption{Reduction Rules.}
\end{figure}


	

\section{Aux}

\subsection{$\Delta$}

Definition of $\Delta(I)(J.f)$:
$\Delta(I)(J.f) = K$, where $K \; J.f \in \overline{K \; J.f}$, where $static \; I \; of (\overline{K \; J.f});$ is the method constructor of interface $I$.

\subsection{calField}
$ calField(I, J, \overline{K.f=e}, f_i)$
\begin{itemize}
	\item if $I.f_i \in \overline{K.f}$, return $e_i$ where $I.f_i = e_i$
	\item if $J.f_i \in \overline{K.f}$, return $e_i$ where $J.f_i = e_i$ 
\end{itemize}

\subsection{updateField}
similar as $calField$.

\subsection{validMC}
$\validMC(I, \overline{I_x}, \overline{J.x}) $:
\begin{itemize}
	\item If there are no abstract state operations, then empty argument list is valid.
	\item $\forall J.x \in \overline{J.x}, J.x \text{ is a valid field of } I, \text{ and can be seen as abstrate state operations, and the type matches } I_x$.
	\item The interface $I$ can be instantiated, meaning that, every abstrate field appears in the argument list of the constructor method.
\end{itemize}

\subsection{The Method Lookup Algorithm in \mbody{}}\label{subsec:mbodydef}
$\mbody(m, I_d, I_s)$ denotes the method body lookup function.
We use $I_d, I_s$, since $\mbody$ is usually invoked by a receiver of a method $m$, with its dynamic type $I_d$ and static type $I_s$. Such a function returns the most specific method implementation. More
accurately, $\mbody$ returns the parameters, returned expression
(empty for abstract methods) and the types for the method. It considers both originally-defined methods and hierarchical overriding methods, so $\mostSpecific$ and $\mostSpecificOverride$ (see the definition in Section~\ref{sec:mostSpecific} and Section~\ref{sec:mostSpecificOverride}) are both invoked.

\saveSpaceFig
\begin{flalign*}
	& \rhd \textit{Definition of } \mbody(m, I_d, I_s): & \\
	& \bullet \mbody(m, I_d, I_s) = (J, \overline{I_x} \; \overline{x}, I_e \; e_0) & \\
	& \indent\indent \textrm{with: } \mostSpecific(m, I_d, I_s) = \{I\} & \\
	& \hspace{.77in} \mostSpecificOverride(m, I_d, I) = \{J\} & \\
	& \hspace{.77in} J[m\ \kwoverride\ I] = \method{I_e}{m}{I_x}{x}{I}{e_0} & \\
	& \bullet \mbody(m, I_d, I_s) = (J, \overline{I_x} \; \overline{x}, I_e \; \o) & \\
	& \indent\indent \textrm{with: } \mostSpecific(m, I_d, I_s) = \{I\} & \\
	& \hspace{.77in} \mostSpecificOverride(m, I_d, I) = \{J\} & \\
	& \hspace{.77in} J[m\ \kwoverride\ I] = \absmethod{I_e}{m}{I_x}{x}{I} & \\
\end{flalign*}
\saveSpaceFig

To calculate $\mbody(m, I_d, I_s)$, the invocation of $\mostSpecific$ looks for the most specific original methods and their interfaces, and expects a singleton set, so as to achieve unambiguity. Furthermore, the invocation of $\mostSpecificOverride$ also expects a unique and most specific hierarchical override. And finally the target method is returned.

\subsection{\mostSpecific}\label{sec:mostSpecific}
We proceed to give the definitions of two core functions that support method lookup, namely \mostSpecific{} and \mostSpecificOverride. Generally,
$\mostSpecific(m, I, J)$ finds the set of most specific interfaces where $m$ is originally defined. Interfaces in this set should be above interface $I$ and along path $J$. Finally with $\prune$ (defined in Section~\ref{sec:otherdefs})
the overridden interfaces will be filtered out.

\saveSpaceFig
\begin{flalign*}
	& \rhd \textit{Definition of } \mostSpecific(m, I, J): & \\
	& \bullet \mostSpecific(m, I, J) = \prune(origins) & \\
	& \indent\indent \textrm{with: } origins = \{K \mid \subt{I}{K}, \textrm{ and } \subt{K}{J} \; \lor \; \subt{J}{K}, &\\
	& \hspace{1.62in} \textrm{ and } K[m\ \kwoverride\ K] \textrm{ is defined} \} &
\end{flalign*}
By the definition, an interface belongs to $\mostSpecific(m, I, J)$ if and only if:
\begin{itemize}
	\item It originally defines $m$;
	\item It is a supertype of $I$ (including $I$);
	\item It is either a supertype or a subtype of $J$ (including $J$);
	\item Any subtype of it does not belong to the same result set because of $\prune$.
\end{itemize}
\saveSpaceFig

\subsection{\mostSpecificOverride}\label{sec:mostSpecificOverride}
The $\mostSpecific$ function only focuses on original method
implementations, where all the hierarchical overriding methods are omitted
during that step. On the other hand, $\mostSpecificOverride(m, I, J)$
has the assumption that $J$ defines an original $m$, and this function
tries to find the interfaces with the most specific implementations that hierarchically overrides such an $m$. Formally,

\saveSpaceFig
\begin{flalign*}
	& \rhd \textit{Definition of } \mostSpecificOverride(m, I, J): & \\
	& \bullet \mostSpecificOverride(m, I, J) = \prune(overrides) & \\
	& \indent\indent \textrm{with: } overrides = \{K \mid \subt{I}{K}, \; \subt{K}{J} \textrm{ and } K[m\ \kwoverride\ J] \textrm{ is defined} &
\end{flalign*}
\saveSpaceFig

By the definition, an interface belongs to $\mostSpecificOverride(m, I, J)$ if and only if:
\begin{itemize}
	\item it is between $I$ and $J$ (including $I$, $J$);
	\item it hierarchically overrides $J.m$;
	\item any subtype of it does not belong to the same set.
\end{itemize}

\subsection{others}\label{sec:otherdefs}
Below we give other minor definitions of the auxiliary functions that are used in previous sections.

%%%%============================ I[m override J] ================%%%%%%%%
\begin{flalign*}
	& \rhd \textit{Definition of } I[m\ \kwoverride\ J]: & \\
	& \bullet I[m\ \kwoverride\ J] = \method{I_e}{m}{I_x}{x}{J}{e_0} & \\
	& \indent\indent \textrm{with: }
	\kwinterface \; I \; \kwextends \; \overline{I} \; \{ \method{I_e}{m}{I_x}{x}{J}{e_0} \ldots \} & \\
	& \bullet I[m\ \kwoverride\ J] = \absmethod{I_e}{m}{I_x}{x}{J} & \\
	& \indent\indent \textrm{with: }
	\kwinterface \; I \; \kwextends \; \overline{I} \; \{ \absmethod{I_e}{m}{I_x}{x}{J} \ldots \} & \\
\end{flalign*}
Here $I[m\ \kwoverride\ J]$ is basically a direct lookup for method $m$ in the body of $I$, where such a method
overrides $J$ (like static dispatch). The method can be either concrete or abstract, and the body of definition is returned. Notice that
by our syntax, $I[m\ \kwoverride\ I]$ is looking for the originally-defined method $m$ in $I$.
%%%%============================ I[m override J] end================%%%%%%%%

%%%%============================ prune(set) ================%%%%%%%%
\saveSpaceFig
\begin{flalign*}
	& \rhd \textit{Definition of } \prune(set): & \\
	& \bullet \prune(set) = \{I \in set \; | \; \nexists J \in set\setminus I, J <: I\} &
\end{flalign*}

The $\prune$ function takes a set of
types, and filters out those that have subtypes in the same set. In the returned set,
none of them has subtyping relation to one another, since all supertypes have been removed.
%%%%============================ prune(set) end ================%%%%%%%%

\subsection{$\Delta$}
\saveSpaceFig
\begin{flalign*}
	& \rhd \textit{Definition of } \Delta_f(I)(J.f) & \\
	& I', \text{ where } J == I  \text{ and } I' f(); \text{ defined in } I. & \\
	& I'', \text{ where } I'' f(); \text{ defined in } J \text{ and } \forall I \subtype J' 
	\subtype J, \text{ there is no field } f \text{ defined in } J'.   &
\end{flalign*}

\subsection{$\eval(Sc, x)$}
\saveSpaceFig
\begin{flalign*}
	& \rhd \textit{Definition of } \eval(Sc, x): & \\
	& \bullet \eval(Sc, x) = Sc(x), x \in dom(Sc) & 
\end{flalign*}

\subsection{example}
\begin{lstlisting}
interface I {
	int x();
	static I of(int I.x);
}

interface A {
	int x();
}
interface B {
	int x();
}
interface C extends A, B {
	static C of (int A.x, int B.x);
}
C.of(3,2)
\end{lstlisting}

\section{Proof}
\subsection{Properties}
\begin{theorem}[Subject Reduction]~\label{theorem_subject}
If $\judgeewf \Gamma {e : I}$ and $\mu | e \rightarrow \mu' | e'$, 
then $\judgeewf \Gamma {e' : I}$.
\end{theorem}
\begin{proof} ~\\
\indent \textbf{Case E-Invk.} Let
  $$e = (J)o.m(\overline{v}) \quad \judgeewf {\Gamma} {e : I_e}$$
  $$e' = (I_{e_0})[\overline{(I_x)v}/\overline{x}, (I_0)o/\kwthis]e_0$$
  $$\mbody(m, I, J) = (I_0, \overline{I_x} \; \overline{x}, I_{e_0} \; e_0)$$

Since $\mbody(m, I, J)$ is defined, the definition of $\mbody$ ensures that $I \subtype J$. And since $e$ is well-typed, by \textsc{(T-Invk)},
  $$\judgeewf {\Gamma} {\overline{v} : \overline{I_v}} \quad \overline{I_v} \subtype \overline{I_x}$$

By the rule \textsc{(T-Cast)},
  $$\judgeewf {\Gamma} {\overline{(I_x)v} : \overline{I_x}} \quad \judgeewf {\Gamma} {(I_0)\new{I} : I_0}$$
  
On the other hand, by Lemma~\ref{lemma:return_expr_typing},
  $$\judgeewf {\overline{x} : \overline{I_x}, \kwthis: I_0} {e_0 : I'_{e_0}} \quad I'_{e_0} \subtype I_{e_0}$$
  
By Lemma~\ref{lemma:weakening},
  $$\judgeewf {\Gamma, \overline{x} : \overline{I_x}, \kwthis: I_0} {e_0 : I'_{e_0}}$$

Hence by Lemma~\ref{lemma:subst_type_preservation}, the substitution preserves typing, thus
  $$\judgeewf {\Gamma} {[\overline{(I_x)v}/\overline{x}, (I_0)o/\kwthis]e_0 : I'_{e_0}}$$
  
Since $I'_{e_0} \subtype I_{e_0}$, the conditions of \textsc{(T-Cast)} are satisfied, hence $\judgeewf {\Gamma} {e' : I_{e_0}}$. Now we only need to prove that $I_{e_0} = I_e$. Since $I_{e_0}$ is from $\mbody(m, I, J)$, whereas $I_e$ is from $\mbody(m, J, J)$, by the rule \textsc{(T-Invk)} on $e$. Since $I \subtype J$, by Lemma~\ref{lemma:mbody_type_preservation}, $I_{e_0} = I_e$.

\indent \textbf{Case E-New} Let   
$$e = \newI{I}{\overline{v}}$$   
$$e' = (I)o$$   
By the rule \textsc{(T-Constructor)}, $\judgeewf \Gamma e:I$. And by the rule \textsc{(T-Cast)}, $\judgeewf \Gamma e':I$. Proved.

\indent \textbf{Case E-Getter} Let
$$e = (J)o.f()$$
$$e' = (I_F)o_i$$
where $f()$ is a getter with the return type $I_F$. And by the rule \textsc{(T-Cast)}, $\judgeewf \Gamma (I_F)o_i:I_F$. Proved.

\indent \textbf{Case E-Setter}
Similar as \textbf{Case E-Getter}.

\indent \textbf{Case E-Let} Let
$$e = \mylet{I}{x}{o}{e_1}$$
$$e' = [(I)o/x]e_1$$
Assume that $\judgeewf {\Gamma, x : I} e_1 : I_1$, then by the rule \textsc{(T-Let)}, $\judgeewf {\Gamma} \mylet{I}{x}{o}{e_1} : I_1$.
By Lemma~\ref{lemma:subst_type_preservation}, $\judgeewf \Gamma [(I)o/x]e_1 : I_1$. Proved.

\indent \textbf{Case E-Cast} 
Let $e = (J)(I)o$ and $e' = (J)o$, then $\judgeewf \Gamma e : J$ and $\judgeewf \Gamma e' : J$ immediately from the rule \textsc{(T-Cast)}.

\indent \textbf{Case E-CTX}
Let $e = \varepsilon\{e_1\}$ and $e' = \varepsilon\{e_1'\}$.
By the induction condition $\mu \mid e_1 \to \mu' \mid e_1'$ and the hypothesis:
if $\judgeewf \Gamma e_1:J$ and $\mu \mid e_1 \to \mu' \mid e_1'$, then 
$\judgeewf \Gamma e_1' : J$. Assume that $\judgeewf \Gamma {\varepsilon\{e_1\} : I}$, then by Lemma~\ref{lemma:subst_type_preservation}, 
$\judgeewf \Gamma {\varepsilon\{e_1'\} : I}$. Proved.
\end{proof}

\begin{theorem}[Progress]~\label{theorem_progress}
Suppose $e$ is a well-typed expression, if $e$ includes 
$(J)o.m(\overline{v})$ as a sub-expression, where $\mu(o) = \newI{I}{...}$, then one of the following conditions holds: 
\begin{enumerate}
	\item \# $\overline{v} = 0$, validGetter(m, I, J) 
	\item \# $\overline{v} = 1$, validSetter(m, I, J)
	\item $\mbody(m, I, J) = (I_0, \overline{I_x} \; \overline{x}, I_e\; e_0)$ and $\num{\overline{x}} = \num{\overline{v}}$ for some $I_0$, $\overline{I_x}$, $\overline{x}$, $I_e$ and $e_0$.
\end{enumerate}
\end{theorem}
\begin{proof} 
Since $e$ is well-typed and includes $(J)o.m(\overline{v})$ as a sub-expression. 
Then the sub-expression $(J)o.m(\overline{v})$ can be divided into three cases:
\begin{enumerate}
	\item $m$ is a getter, validGetter(m, I, J) and getters contain no parameter. And by the rule \textsc{(T-Invk)}, the number of arguments is the same to the number of parameters of the method(getter), which is 0. 
	\item $m$ is a setter, validSetter(m, I, J) and setters contain one and only one parameter. By the rule \textsc{(T-Invk)}, the number of arguments is the same to the number of parameters of the method(setter), which is 1. 
	\item $m$ is neither a getter or setter, by the rule \textsc{(T-Invk)} we know that
	$$I \subtype J\textrm{, and }\mbody(m, J, J) \textrm{ is defined}$$

	By \textsc{(T-Intf)}, $\mbody(m, I, J)$ is also defined, and the type checker ensures the expected number of arguments.

	On the other hand, since $I \subtype J$, by the definition of $\mostSpecific$, $$\mostSpecific(m, I, J) \subseteq \mostSpecific(m, I, I)$$

	By \textsc{(T-New)}, assume $mconstr(I) = \overline{I_x} \; \overline{x}$ and MC OK in interface I. $\validMC(I, \overline{I_x} \; \overline{x}) = True$. By the definition of $\validMC$, any $J_0\in\mostSpecific(m, I, I)$ satisfies that
	$\mostSpecificOverride(m, I, J_0)$ contains only one interface, in which the $m$ that overrides $J_0$ is a concrete method. Therefore $\mbody(m, I, J)$ also provides a concrete method, which finishes the proof.
\end{enumerate}
\end{proof}

% \begin{theorem}[Progress]~\label{theorem_progress}
% Suppose $e$ is a well-typed expression, if $e$ includes 
% $(J)o.m(\overline{v})$ as a sub-expression, where $\mu(o) = \newI{I}{...}$, then  
% $\mbody(m, I, J) = (I_0, \overline{I_x} \; \overline{x}, I_e\; e_0)$ and $\num{\overline{x}} = \num{\overline{v}}$ for some $I_0$, $\overline{I_x}$, $\overline{x}$, $I_e$ and $e_0$.
% \end{theorem}
% \begin{proof}
% See Appendix~\ref{appendix_proof}.
% \end{proof}
% \begin{proof} 
% Since $e$ is well-typed, by \textsc{(T-Invk)} and \textsc{(T-Anno)} we know that
% $$I \subtype J\textrm{, and }\mbody(m, J, J) \textrm{ is defined}$$

% By \textsc{(T-Intf)}, $\mbody(m, I, J)$ is also defined, and the type checker ensures the expected number of arguments.

% On the other hand, since $I \subtype J$, by the definition of $\mostSpecific$, $$\mostSpecific(m, I, J) \subseteq \mostSpecific(m, I, I)$$

% By \textsc{(T-New)}, $\canInstantiate(I) = True$. By the definition of $\canInstantiate$, any $J_0\in\mostSpecific(m, I, I)$ satisfies that
% $\mostSpecificOverride(m, I, J_0)$ contains only one interface, in which the $m$ that overrides $J_0$ is a concrete method. Therefore $\mbody(m, I, J)$ also provides a concrete method, which finishes the proof.
% \end{proof}

\begin{theorem}[Type Soundness]~\label{theorem_soundness}
If $\judgeewf \o {e : I}$ and $\o | e \to^* \mu | e'$ with $e'$ a normal form, then $e'$ is 
a value $v$ with $\judgeewf \o {v:I}$.
\end{theorem}
\begin{proof}
Immediate from Theorem~\ref{theorem_subject} and Theorem~\ref{theorem_progress}.
\end{proof}

\begin{theorem}[Determinacy of One-Step Evaluation]~\label{theorem_determinacy}
	If $\mu \mid t \to \mu' \mid t'$ and $\mu \mid t \to \mu'' \mid t''$, then $t' = t''$ and $\mu' = \mu''$.
\end{theorem}
\begin{proof}	
The Proof is done by induction on a derivation of $\mu \mid t \to \mu' \mid t'$, following the book  \emph{TAPL}.
\begin{itemize}
	\item If the last rule used in the derivation of $\mu \mid t \to \mu' \mid t'$ is \textsc{(E-Invk)}, then we know that $t$ has the form $(J)o.m(\overline{v})$ with $\mu(o) = \newI{I}{...}$, $I, J, m$ determined. Now it is obvious that the last rule in the derivation of $\mu \mid t \to \mu'' \mid t''$ should also be \textsc{(E-Invk)} with the same $I, J, m$. Since $\mbody(m, I, J)$ is a \emph{function} that given the same input will calculate the same result, we know the two induction results are the same, thus $t' = t''$ is immediately proved. Also from the rule \textsc{(E-Invk)}, we know that $\mu$ is unchanged, thus $\mu' = \mu'' = \mu$ is also proved.
	
	\item If the last rule used in the derivation of $\mu \mid t \to \mu' \mid t'$ is \textsc{(E-New)}, then the form of $t$ is fixed to be $\newI{I}{\overline{v}}$. The only rule applies in $\mu \mid t \to \mu'' \mid t''$ is also \textsc{(E-New)}. From the rule \textsc{(E-New)} we know that $t' = t'' = (I)o$ and $\mu' = \mu'' = \mu, o \to \newI{I}{\overline{v}}$ proved.
	
	\item If the last rule used in the derivation of $\mu \mid t \to \mu' \mid t'$ is \textsc{(E-Cast)}, then the form of $t$ is fixed to be $(I)((J)o)$. Since $(J)o$ is not reducible, the only rule applies in $\mu \mid t \to \mu'' \mid t''$ is \textsc{(E-Cast)}. Also from the rule \textsc{(E-Cast)} we know that $\mu$ is unchanged, thus $t' = t'' = (I)o$ and $\mu' = \mu'' = \mu$ proved.
	
	\item If the last rule used in the derivation of $\mu \mid t \to \mu' \mid t'$ is \textsc{(E-Let)}, then the form of $t$ is fixed to be $\mylet{I}{x}{o}{e}$. And the only rule applies in $\mu \mid t \to \mu'' \mid t''$ is \textsc{(E-Let)}. Also from the rule \textsc{(E-Cast)} we know that $\mu$ is unchanged, thus $t' = t'' = e[(I)o/x]$ and $\mu' = \mu'' = \mu$ proved.
	
	\item If the last rule used in the derivation of $\mu \mid t \to \mu' \mid t'$ is \textsc{(E-Getter)}, then the form of $t$ is fixed to be $(J)o.f()$. For the second reduction $\mu \mid t \to \mu'' \mid t''$, the rule \textsc{(E-Setter)} does not apply because the number of parameters does not match. Also the rule \textsc{(E-Invk)} does not match because the precondition $!validGetter(m, I, J)$ is not satisfied. The only rule applies  is the rule \textsc{(E-Getter)}. Also from the rule \textsc{(E-Getter)} we know that $\mu$ is unchanged, thus $t' = t'' = (I_F)o_i$ and $\mu' = \mu'' = \mu$ proved.
	
	\item If the last rule used in the derivation of $\mu \mid t \to \mu' \mid t'$ is \textsc{(E-Setter)}, then the form of $t$ is fixed to be $(J)o.SET_f((I')o)$. Then for the second reduction $\mu \mid t \to \mu'' \mid t''$, the rule \textsc{(E-Getter)} does not apply because the number of parameters does not match. Also the rule \textsc{(E-Invk)} does not match because the precondition $!validSetter(m, I, J)$ is not satisfied. The only rule applies is the rule \textsc{(E-Setter)}. And from the rule \textsc{(E-Setter)}, we know that $t' = t'' = (I)o$. Assume in the first derivation $\mu \mid t \to \mu' \mid t'$, $\mu = \mu_0, o \to \newI{I}{o_1,...,o_i,...,o_n}, \mu' = \mu_0, o \to \newI{I}{o_1,...,o',...,o_n}$, then in the second derivation $\mu \mid t \to \mu'' \mid t''$, $\mu = \mu_0, o \to \newI{I}{o_1,...,o_i,...,o_n}, \mu'' = \mu_0, o \to \newI{I}{o_1,...,o',...,o_n} = \mu'$. Proved.

	\item \item If the last rule used in the derivation of $\mu \mid t \to \mu' \mid t'$ is \textsc{(E-CTX)}, 
\end{itemize}
\end{proof}


\subsubsection{Proof for Theorem~\ref{theorem_subject}}



\subsubsection{Proof for Theorem~\ref{theorem_progress}}



\subsubsection{Proof for Theorem~\ref{theorem_determinacy}}
