#Review 60A

> "isn't multiple overriding essential to resolving diamond inheritance
conflicts? If that is so, I think multiple overriding needs to be part
of the core calculus."

Multiple overriding isn't essential to resolving diamond inheritance
conflicts, and the paper does have a few examples that show how to deal
with such conflicts.

One important feature for diamond inheritance is the ability to
*merge* methods coming from different parents. Our calculus
supports merging methods, so it can deal with common instances of the
diamond problem. For example, here is a typical scenario
for diamond inheritance:

interface A {void m() {}}
interface B extends A {void m() {}}
interface C extends A {void m() {}}

interface D extends B, C {void m() {}}  // D.m overrides&merges B.m and  C.m

*This program is accepted* in our calculus and indeed it is presented
in diagram form in Figure 3 (case f).

*Importantly*, note that the definition of D, after desugaring, is:

interface D extends B, C {
  void m() overrides D {}
}

*Overriding the class itself* in our calculus is how we enable merging
of methods. We will make this clearer in the paper!

Multiple overriding would be useful in the following situation:

interface A {void m() {}}
interface B {void m() {}}
interface C {void m() {}}

interface D extends A, B, C {
  void m() overrides A,B {}   // overrides and merges A.m and B.m only
  void m() overrides C {}
}

In this case we would like to inherit from 3 interfaces with
conflicting methods, but only merge 2 of those methods.
While we can largely simulate D without multiple overriding in our calculus
(by introducing an intermediate class), a better approach would be
to support the approach natively.

As a final note we do have a formalization/implementation of multiple
overriding, but the proofs are still in progress. 

> "Presumably C++ compilers already have figured out how to efficiently
  implement hierarchical dispatch; does hierarchical overriding pose
  any challenges in that regard?"

C++ method lookup of static calls and non-virtual calls are determined
at compile-time and optimized to be very efficient. For hierarchical
dispatch that uses C++ virtual calls, the resolution is done at
run-time by looking up the virtual tables. We haven't yet carefully
thought about changes to current implementations, but we believe that
static and non-virtual calls can remain the same, and we can change
the vtables by adding tags (which specify the branch) to functions in
vtables and change the vtable lookup algorithm accordingly.

We believe that such approach would not have a very signicant impact
on the performance of method lookup, but without an implementation
and performance experiements, this is just speculation at this point.

#Review 60B

> how it can coexist with solutions for the diamond problem.

Although our model has some differences to the trait model
it is heavily inspired by it (see discussions in Section 2.1.1.III page 5, Section 5.1)!

As a result it can deal with the diamond problem in a very similar way
to the trait approach or the Java approach with default methods.
Nevertheless there are some differences to both of these models.
Our paper show examples of the diamond problem and discusses
new issues that arise when hierarchical dispatching/overriding are
added (see page 9 Figure (d)(e)(f)).

See also the first reply to #Review 60A.

In C++, diamond problems occur when using normal inheritance. With virtual inheritance, the problem is solved. 
In our model, "virtual" is assumed, thus our solution does solve diamond problem.

#Review 60C

> There is no discussion of the implementation in the paper. ...
> Did you learn anything from the prototype?

We will add a discussion about the implementation to the paper.

The implementation was used to encode all the examples presented in the paper, 
as stated in the last point of the contributions (page 3). The
implementation is done in Scala and one nice feature is that it can
show the detailed step-by-step evaluation of the program, which
is great for understanding and debugging programs&semantics.
