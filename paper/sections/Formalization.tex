\section{Formalization}

In this section, we present a formalization of our MIM calculus, based on
a minimal subset of Java 8 interfaces. The syntax, typing rules and small-step
semantics are included below.

\subsection{Syntax}
Figure~\ref{fig:syntax} shows the syntax of MIM. The multiple inheritance feature
of MIM has a basis on Java interfaces. To demonstrate how unintentional method conflicts
are untangled in MIM, we present the calculus in a straightforward way, hence we only
focus on a small subset of the interface model. For example, all the methods declared in an
interface are default methods, that is to say, they always provide default implementations.
From this point we can view that we are actually modelling a class model that supports multiple
inheritance. Then it is straightforward to do object creation like ``\new I''. Fields and
primitive types are not modelled as well.

We use uppercase letters like $I, J, K$ to represent identifiers for interfaces. By multiple inheritance,
an interface can have a set of super interfaces, where such a set can be empty. Inside an interface are a
set of method declarations. Each method body holds a return statement. As seen in Figure~\ref{fig:syntax},
we have introduced the \kwoverride keyword to override an old implementation of the method. If the interface
that it overrides is exactly the enclosing interface, then such a method is seen as ``originally defined''.
Again for simplicity, overloading is not modelled for methods, which implies we can uniquely identify a method
by its name.

An expression can be a variable, a method invocation, an object creation, furthermore, a path-invocation like
``$e.I::m(\overline{e})$'', meaning that the dynamically binded implementation for method $m$ should be along
the path $I$. Another case is the super-invocation, enabling a method to access an old implementation from the
specified super type. Hence a super-invocation can only be used inside an interface definition. Finally an expression
can also be a value ``$<I> \new J$''. It is exactly an object instance of $J$ with annotated static type $I$.
Note that values are only intended for the small-step semantics of MIM, hence they are not supposed to appear in the source program.

\begin{figure*}[htbp]
\begin{displaymath}
\begin{array}{l}
\begin{array}{llrl}
\text{Interfaces}   & IL & \Coloneqq & \interface{I}{I}{M} \\
\text{Methods}      & M  & \Coloneqq & \method{I}{m}{I}{x}{J}{e} \\
\text{Expressions}  & e  & \Coloneqq & x \mid
e.m(\overline{e}) \mid
\new{I} \mid
e.I::m(\overline{e}) \mid
\kwsuper.I::m(e) \; \red{\mid} \; \red{v^*} \\
\text{Context}      & \Gamma & \Coloneqq & x_1:I_1 ... x_n:I_n \\
\text{\red{Values}}       & v & \Coloneqq & <I>\new{J} \\
\\
\text{Interface names} & I, J, K & & \\
\text{Method names} & m & & \\
\text{Variable names} & x & &
\end{array}
\end{array}
\end{displaymath}
\caption{Syntax. \red{*: only intended for semantic rules.}}\label{fig:syntax}
\end{figure*}

\subsection{Subtyping}
See Figure~\ref{fig:subtyping}.

\begin{figure*}[htbp]
\begin{mathpar}
	\framebox{$ I <: J $} \hspace{.5in} \subid \\
	\subtrans \hspace{.5in} \subextends
\end{mathpar}
\caption{Subtyping.}\label{fig:subtyping}
\end{figure*}

\subsection{Typing Rules}
See Figure~\ref{fig:typingrules}.

\begin{figure*}[htbp]
\begin{mathpar}
	\framebox{$ \judgeewf \Gamma {e:I} $} \hspace{.5in}
	\tvar \\
	\tinvk \\
	\tpathinvk \\
	\tsuperinvk \\
	\tnew \\
	\tmethod \\
	\tintf
\end{mathpar}
\caption{Typing rules.}\label{fig:typingrules}
\end{figure*}

\subsection{Small-step Semantics}
See Figure~\ref{fig:smallstep}.

\begin{figure*}[htbp]
\begin{mathpar}
	\sinvk \\
	\spathinvk \\
	\ssuperinvk
\end{mathpar}
\caption{Small-step semantics.}\label{fig:smallstep}
\end{figure*}



\subsection{Congruence}
See Figure~\ref{fig:congruence}.

\begin{figure*}[htbp]
\begin{mathpar}
	\creceiver \hspace{.5in}
	\red{\cpathreceiver} \\
	\red{\cargs} \\
	\red{\cpathargs} \\
	\red{\csuperargs} \\
	\cstatictype \\
	\cfreduce \\
	\cannoreduce
\end{mathpar}
\caption{Congruence.}\label{fig:congruence}
\end{figure*}



\subsection{Auxilary Definitions}

\begin{figure*}[htbp]
	\begin{mathpar}
	\inferrule* [left=]
		{  \mostSpecific(m, I_d, I_s) = \{I\} \\
			\mostSpecific_3(m, I_d, I) = \{J\} \\
			\kwinterface \; J \; \kwextends \; \overline{J} \; \{\method{I_E}{m}{I_X}{x}{I}{e_0}\ldots\}}
		{\mbody(m, I_d, I_s) = (\overline{I_X} \; \overline{x}, I_E \; e_0)}
	
	\inferrule* [left=]
	{ set = \; $\{$ K <: J \; $and$ \; K >: I \; | \; m \in dom(K) \} }
	{\mostSpecific(m, I, J) = \left\{{\begin{tabular}{ll}
				$prune(set)$ & if $set$ is not empty \\ $\mostSpecific_2(m, J)$ & otherwise
			\end{tabular}}\right.}
	\inferrule* [left=]
		{ set = \; $\{$ K >: I \; | \; m \in dom(K) \} }
		{\mostSpecific_2(m, I) = prune(set)}
	
	\inferrule* [left=]
		{ set = \; $\{$ K <: J \; $and$ \; K >: I \; | \;
			\kwinterface \; K \; \kwextends \; \overline{K} \; \{ I_E \; m(\overline{I_X} \; \overline{x}) \;
			\kwoverride \; J \ldots \}  $\}$ }
		{\mostSpecific_3(m, I, J) = prune(set)}
	
	prune(set) = \{I \in set \; | \; \nexists J \in set, J <: I, J \neq I \}
	
	\inferrule* [left=]
	{   \interface{I}{I}{M}
		\\ J \in \overline{I} }
	{\ext(I, J)}
	\end{mathpar}
	\caption{Auxiliary functions.}\label{fig:auxfunc}
\end{figure*}


\subsubsection{\mbody}

$\mbody(m, I_d, I_s)$, as defined in Figure~\ref{fig:auxfunc}, denotes a method lookup function.
We use $I_d, I_s$, since $\mbody$ is usually invoked by a receiver of a method $m$, with its dynamic
type $I_d$ and static type $I_s$. Such a function returns the most specific method implementation, more
accurately, its parameters, returned expression and the types.

To calculate $\mbody(m, I_d, I_s)$:
\begin{itemize}
	\item First, an auxiliary function $\mostSpecific(m, I_d, I_s)$ returns the set of interfaces that
	originally defines the most specific implementations of method $m$. We use another helper function $prune$ to ensure that none of those implementations overrides one another.
	\item If $\mostSpecific$ returns a singleton set $\{I\}$, then it is good, otherwise $\mbody$ is undefined in
	this case. The set $\{I\}$ implies that we will use the $m$ from $I$ without ambiguity. But moreover, we have to invoke $\mostSpecific_3(m, I_d, I)$, to check if there are updated versions of $m$ between $I_d$ and $I$. Again we forbid ambiguity, so the expected set after pruning is also a singleton set $\{J\}$.
	\item Finally, we fetch the implementation of $m$ in interface $J$ and return.
\end{itemize}

\begin{comment}
$mbody(m, I)$ algorithm:
\begin{itemize}
	\item If m is defined in I directly, then return I.m()
	\item Else, let $\overline{I'} = mdefined(fathers(I))$, all ancestors of $I$ that has directly defined $m()$.
	\item $\overline{I''} = needed(\overline{I'})$, keep only interfaces that are needed, which are not super-interface of others.
	\item If $\overline{I''}$ is unique, then return this unique one. Else if any two I1,I2 in $\overline{I''}$ share a parent in $\overline{I'}$, then diamond conflict is detected, report error. Else return multiple $m()$s.
\end{itemize}
\end{comment}

\subsubsection{\mostSpecific}

\haoyuan{TODO}

\subsubsection{\mtype}
$\mtype(m, C)$ algorithm:
\begin{itemize}
	\item If the result of $\mbody(m, C, A)$ is a unique method,\\
	$\method{I_0}{m}{I}{x}{J}{e_0}$,\\
	then $\mtype(m, C) = \overline{I} \to I_0$
	\item Else ($\Undefined$ or multiple methods returned), $\mtype(m, C) = \Error$
\end{itemize}



\subsubsection{\ext}
\ext(I,J) means interface $I$ (directly) extends $J$.



\subsubsection{\collectMethods}
\[ \collectMethods(I) = \left( \bigcup_{I_i \in \overline{I}} \methods(I_i) \right) \bigcup \methods(I) \]
\[ \methods(I) = \overline{M}, \text{where } IT(I) = \interface{I}{I}{M} \]



\subsubsection{\needed}

\subsubsection{\only}
$\only(m, I)$ is true iff inside $I$ there is only one (direct) methoed $m$ definition.


\begin{itemize}
	\item Syntax + typing rules + Semantics + Auxiliary definitions
	\item Implementation: a simple type checker + interpreter in Scala
\end{itemize}


