\section{Formalization}


\begin{itemize}
	\item Syntax + typing rules + Semantics + Auxiliary definitions
	\item Implementation: a simple type checker + interpreter in Scala
\end{itemize}

\subsection{Syntax}
See Figure~\ref{fig:syntax}.
$I$, $J$ represents interfaces. 
\kwsuper can only be used inside interface definition.

\begin{figure*}[htbp]
\begin{displaymath}
\begin{array}{l}
\begin{array}{llrl}
\text{Interfaces}   & IL & \Coloneqq & \interface{I}{I}{M} \\
\text{Methods}      & M  & \Coloneqq & \method{I}{m}{I}{x}{J}{e} \\
\text{Expressions}  & e  & \Coloneqq & x \mid
e.m(\overline{e}) \mid
\new{I} \mid
e.I::m(\overline{e}) \mid
\kwsuper.I::m(e) \; \red{\mid} \; \red{v^*} \\
\text{Context}      & \Gamma & \Coloneqq & x_1:I_1 ... x_n:I_n \\
\text{\red{Values}}       & v & \Coloneqq & <I>\new{J} \\
\\
\text{Interface names} & I, J, K & & \\
\text{Method names} & m & & \\
\text{Variable names} & x & &
\end{array}
\end{array}
\end{displaymath}
\caption{Syntax. \red{*: only intended for semantic rules.}}\label{fig:syntax}
\end{figure*}

\subsection{Subtyping}
See Figure~\ref{fig:subtyping}.

\begin{figure*}[htbp]
\begin{mathpar}
	\framebox{$ I <: J $} \hspace{.5in} \subid \\
	\subtrans \hspace{.5in} \subextends
\end{mathpar}
\caption{Subtyping.}\label{fig:subtyping}
\end{figure*}

\subsection{Typing Rules}
See Figure~\ref{fig:typingrules}.

\begin{figure*}[htbp]
\begin{mathpar}
	\framebox{$ \judgeewf \Gamma {e:I} $} \hspace{.5in}
	\tvar \\
	\tinvk \\
	\tpathinvk \\
	\tsuperinvk \\
	\tnew \\
	\tmethod \\
	\tintf
\end{mathpar}
\caption{Typing rules.}\label{fig:typingrules}
\end{figure*}

\subsection{Small-step Semantics}
See Figure~\ref{fig:smallstep}.

\begin{figure*}[htbp]
\begin{mathpar}
	\framebox{$ e \rightarrow v $} \hspace{.5in}
	\sinvk \\
	\spathinvk \\
	\ssuperinvk
\end{mathpar}
\caption{Small-step semantics.}\label{fig:smallstep}
\end{figure*}



\subsection{Congruence}
See Figure~\ref{fig:congruence}.

\begin{figure*}[htbp]
\begin{mathpar}
	\creceiver \hspace{.5in}
	\red{\cpathreceiver} \\
	\red{\cargs} \\
	\red{\cpathargs} \\
	\red{\csuperargs} \\
	\cstatictype \\
	\cfreduce \\
	\cannoreduce
\end{mathpar}
\caption{Congruence. \haoyuan{How are the last two rules used?}}\label{fig:congruence}
\end{figure*}



\subsection{Auxilary Definitions}

\begin{figure*}[htbp]
	\begin{mathpar}
	\inferrule* [left=]
		{  \mostSpecific(m, I_d, I_s) = \{I\} \\
			\mostSpecific_3(m, I_d, I) = \{J\} \\
			\kwinterface \; J \; \kwextends \; \overline{J} \; \{\method{I_E}{m}{I_X}{x}{I}{e_0}\ldots\}}
		{\mbody(m, I_d, I_s) = (\overline{I_X} \; \overline{x}, I_E \; e_0)}
	
	\inferrule* [left=]
	{ set = \; $\{$ K <: J \; $and$ \; K >: I \; | \; m \in dom(K) \} }
	{\mostSpecific(m, I, J) = \left\{{\begin{tabular}{ll}
				$prune(set)$ & if $set$ is not empty \\ $\mostSpecific_2(m, J)$ & otherwise
			\end{tabular}}\right.}
	\inferrule* [left=]
		{ set = \; $\{$ K >: I \; | \; m \in dom(K) \} }
		{\mostSpecific_2(m, I) = prune(set)}
	
	\inferrule* [left=]
		{ set = \; $\{$ K <: J \; $and$ \; K \neq J \; $and$ \; K >: I \; | \\
			\kwinterface \; K \; \kwextends \; \overline{K} \; \{ I_E \; m(\overline{I_X} \; \overline{x}) \;
			\kwoverride \; J \ldots \}  $\}$ }
		{\mostSpecific_3(m, I, J) = prune(set)}
	
	prune(set) = \{I \in set \; | \; \nexists J \in set, J <: I, J \neq I \}
	
	\inferrule* [left=]
	{   \interface{I}{I}{M}
		\\ J \in \overline{I} }
	{\ext(I, J)}
	\end{mathpar}
	\caption{Auxiliary functions.}\label{fig:auxfunc}
\end{figure*}


\subsubsection{\mbody}

\begin{comment}
$mbody(m, I)$ algorithm:
\begin{itemize}
	\item If m is defined in I directly, then return I.m()
	\item Else, let $\overline{I'} = mdefined(fathers(I))$, all ancestors of $I$ that has directly defined $m()$.
	\item $\overline{I''} = needed(\overline{I'})$, keep only interfaces that are needed, which are not super-interface of others.
	\item If $\overline{I''}$ is unique, then return this unique one. Else if any two I1,I2 in $\overline{I''}$ share a parent in $\overline{I'}$, then diamond conflict is detected, report error. Else return multiple $m()$s.
\end{itemize}
\end{comment}

\subsubsection{\mostSpecific}

\subsubsection{\mtype}
$\mtype(m, C)$ algorithm:
\begin{itemize}
	\item If the result of $\mbody(m, C, A)$ is a unique method,\\
	$\method{I_0}{m}{I}{x}{J}{e_0}$,\\
	then $\mtype(m, C) = \overline{I} \to I_0$
	\item Else ($\Undefined$ or multiple methods returned), $\mtype(m, C) = \Error$
\end{itemize}



\subsubsection{\ext}
\ext(I,J) means interface $I$ (directly) extends $J$.



\subsubsection{\collectMethods}
\[ \collectMethods(I) = \left( \bigcup_{I_i \in \overline{I}} \methods(I_i) \right) \bigcup \methods(I) \]
\[ \methods(I) = \overline{M}, \text{where } IT(I) = \interface{I}{I}{M} \]



\subsubsection{\needed}

\subsubsection{\only}
$\only(m, I)$ is true iff inside $I$ there is only one (direct) methoed $m$ definition.


