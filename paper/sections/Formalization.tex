\section{Formalization}

In this section, we present a formalization of our MIM calculus, based on
a minimal subset of Java 8 interfaces. The syntax, typing rules and small-step
semantics are included below.

\subsection{Syntax}
Figure~\ref{fig:syntax} shows the syntax of MIM. The multiple inheritance feature
of MIM has a basis on Java interfaces. To demonstrate how unintentional method conflicts
are untangled in MIM, we present the calculus in a straightforward way, hence we only
focus on a small subset of the interface model. For example, all the methods declared in an
interface are default methods, that is to say, they always provide default implementations.
From this point we can view that we are actually modelling a class model that supports multiple
inheritance. Then it is straightforward to do object creation like ``\new I''. Fields and
primitive types are not modelled as well.

We use uppercase letters like $I, J, K$ to represent identifiers for interfaces. By multiple inheritance,
an interface can have a set of super interfaces, where such a set can be empty. Inside an interface are a
set of method declarations. Each method body holds a return statement. As seen in Figure~\ref{fig:syntax},
we have introduced the \kwoverride keyword to override an old implementation of the method. If the interface
that it overrides is exactly the enclosing interface, then such a method is seen as ``originally defined''.
Again for simplicity, overloading is not modelled for methods, which implies we can uniquely identify a method
by its name.

An expression can be a variable, a method invocation, an object creation, furthermore, a path-invocation like
``$e.I::m(\overline{e})$'', meaning that the dynamically binded implementation for method $m$ should be along
the path $I$. Another case is the super-invocation, enabling a method to access an old implementation from the
specified super type. Hence a super-invocation can only be used inside an interface definition. Finally an expression
can also be a value ``$<I> \new J$''. It is exactly an object instance of $J$ with annotated static type $I$.
Note that values are only intended for the small-step semantics of MIM, hence they are not supposed to appear in the source program.

\begin{figure*}[htbp]
\begin{displaymath}
\begin{array}{l}
\begin{array}{llrl}
\text{Interfaces}   & IL & \Coloneqq & \interface{I}{I}{M} \\
\text{Methods}      & M  & \Coloneqq & \method{I}{m}{I}{x}{J}{e} \\
\text{Expressions}  & e  & \Coloneqq & x \mid
e.m(\overline{e}) \mid
\new{I} \mid
e.I::m(\overline{e}) \mid
\kwsuper.I::m(e) \; \red{\mid} \; \red{v^*} \\
\text{Context}      & \Gamma & \Coloneqq & x_1:I_1 ... x_n:I_n \\
\text{\red{Values}}       & v & \Coloneqq & <I>\new{J} \\
\\
\text{Interface names} & I, J, K & & \\
\text{Method names} & m & & \\
\text{Variable names} & x & &
\end{array}
\end{array}
\end{displaymath}
\caption{Syntax. \red{*: only intended for semantic rules.}}\label{fig:syntax}
\end{figure*}

\subsection{Subtyping}
See Figure~\ref{fig:subtyping}. \haoyuan{TODO}

\begin{figure*}[htbp]
\begin{mathpar}
	\framebox{$ I <: J $} \hspace{.5in} \subid \\
	\subtrans \hspace{.5in} \subextends
\end{mathpar}
\caption{Subtyping.}\label{fig:subtyping}
\end{figure*}

\subsection{Typing Rules}
See Figure~\ref{fig:typingrules}. \haoyuan{TODO}

\begin{figure*}[htbp]
\begin{mathpar}
	\framebox{$ \judgeewf \Gamma {e:I} $} \hspace{.5in}
	\tvar \\
	\tinvk \\
	\tpathinvk \\
	\tsuperinvk \\
	\tnew \\
	\tmethod \\
	\tintf
\end{mathpar}
\caption{Typing rules.}\label{fig:typingrules}
\end{figure*}

\subsection{Small-step Semantics}
See Figure~\ref{fig:smallstep}. \haoyuan{TODO}

\begin{figure*}[htbp]
\begin{mathpar}
	\sinvk \\
	\spathinvk \\
	\ssuperinvk
\end{mathpar}
\caption{Small-step semantics.}\label{fig:smallstep}
\end{figure*}



\subsection{Congruence}
See Figure~\ref{fig:congruence}. \haoyuan{TODO}

\begin{figure*}[htbp]
\begin{mathpar}
	\creceiver \hspace{.5in}
	\red{\cpathreceiver} \\
	\red{\cargs} \\
	\red{\cpathargs} \\
	\red{\csuperargs} \\
	\cstatictype \\
	\cfreduce \\
	\cannoreduce
\end{mathpar}
\caption{Congruence.}\label{fig:congruence}
\end{figure*}



\subsection{Auxilary Definitions}

To make our formalization concise and expressive, we have defined a list of
auxiliary functions, collected by Figure~\ref{fig:auxfunc}. To begin with, we
introduce the basic functions: $\ext, \updateSet$ and $\prune$. $\ext(I, J)$
simply indicates that interface $I$ directly extends interface $J$. Corresponding
to this is a more general case $I <: J$, meaning that $I$ is a subtype of $J$.
$\updateSet(I, J)$ returns a set of methods defined in $I$ that have ``$\kwoverride \; J$''
in their signatures. Notice that $\updateSet(I, I)$ is a special representative of
the ``originally-defined'' method set from $I$. The $\prune$ function takes a set of
types, and filters out those that have subtypes in the same set. Finally in the returned set,
none of them has a subtyping to one another, since all super types have been removed.

\begin{figure*}[htbp]
	\begin{mathpar}
	\inferrule* [left=]
		{  \mostSpecific(m, I_d, I_s) = \{I\} \\
			\mostSpecific_2(m, I_d, I) = \{J\} \\
			\kwinterface \; J \; \kwextends \; \overline{J} \; \{\method{I_E}{m}{I_X}{x}{I}{e_0}\ldots\}}
		{\mbody(m, I_d, I_s) = (\overline{I_X} \; \overline{x}, I_E \; e_0)}
	
	\inferrule* [left=]
	{ set1 = \; \{ K <: J \; $and$ \; K >: I \; | \; m \in \updateSet(K, K) \} \\
		set2 = \; \{ K >: J \; | \; m \in \updateSet(K, K) \} }
	{\mostSpecific(m, I, J) = \left\{{\begin{tabular}{ll}
				$prune(set1)$ & if $set1$ is not empty \\ $prune(set2)$ & otherwise
			\end{tabular}}\right.}
	
	\inferrule* [left=]
		{ set = \; \{ K <: J \; $and$ \; K >: I \; | \;
			m \in \updateSet(K, J)  \} }
		{\mostSpecific_2(m, I, J) = prune(set)}
	
	prune(set) = \{I \in set \; | \; \nexists J \in set, J <: I, J \neq I \}
	
	\inferrule* [left=]
	{   \interface{I}{I}{M}
		\\ J \in \overline{I} }
	{\ext(I, J)}
	
	\inferrule* [left=]
	{   \kwinterface \; I \; \kwextends \; \overline{I} \; \{ I_E \; m(\overline{I_X} \; \overline{x}) \;
		\kwoverride \; J \ldots \} }
	{m \in \updateSet(I, J)}
	\end{mathpar}
	\caption{Auxiliary functions.}\label{fig:auxfunc}
\end{figure*}


\subsubsection{\mbody}

$\mbody(m, I_d, I_s)$, as defined in Figure~\ref{fig:auxfunc}, denotes a method body lookup function.
We use $I_d, I_s$, since $\mbody$ is usually invoked by a receiver of a method $m$, with its dynamic
type $I_d$ and static type $I_s$. Such a function returns the most specific method implementation, more
accurately, its parameters, returned expression and the types.

To calculate $\mbody(m, I_d, I_s)$:
\begin{itemize}
	\item First, an auxiliary function $\mostSpecific(m, I_d, I_s)$ returns the set of interfaces that
	originally defines the most specific implementations of method $m$. We use another helper function $prune$ to ensure that none of those implementations overrides one another.
	\item If $\mostSpecific$ returns a singleton set $\{I\}$, then it is good, otherwise $\mbody$ is undefined in
	this case. The set $\{I\}$ implies that we will use the $m$ from $I$ without ambiguity. But moreover, we have to invoke $\mostSpecific_3(m, I_d, I)$, to check if there are updated versions of $m$ between $I_d$ and $I$. Again we forbid ambiguity, so the expected set after pruning is also a singleton set $\{J\}$.
	\item Finally, we fetch the implementation of $m$ in interface $J$ and return.
\end{itemize}

\begin{comment}
$mbody(m, I)$ algorithm:
\begin{itemize}
	\item If m is defined in I directly, then return I.m()
	\item Else, let $\overline{I'} = mdefined(fathers(I))$, all ancestors of $I$ that has directly defined $m()$.
	\item $\overline{I''} = needed(\overline{I'})$, keep only interfaces that are needed, which are not super-interface of others.
	\item If $\overline{I''}$ is unique, then return this unique one. Else if any two I1,I2 in $\overline{I''}$ share a parent in $\overline{I'}$, then diamond conflict is detected, report error. Else return multiple $m()$s.
\end{itemize}
\end{comment}

\subsubsection{\mostSpecific}

\haoyuan{TODO}

\subsubsection{\mtype}

\haoyuan{TODO. mtype(m, I) from mbody(I, I).}

\begin{comment}
\subsubsection{\collectMethods}
\[ \collectMethods(I) = \left( \bigcup_{I_i \in \overline{I}} \methods(I_i) \right) \bigcup \methods(I) \]
\[ \methods(I) = \overline{M}, \text{where } IT(I) = \interface{I}{I}{M} \]
\end{comment}

\begin{itemize}
	\item Syntax + typing rules + Semantics + Auxiliary definitions
	\item Implementation: a simple type checker + interpreter in Scala
\end{itemize}

\subsubsection{A Non-Trivial Example}

\[
\begin{array}{l}
\kwinterface \; A \; \kwextends \; \{ \\
\; \; \; \; A \; m() \; \kwoverride \; A \; \{\kwreturn \; \new A;\} \\
\} \\
\\
\kwinterface \; B \; \kwextends \; A \; \{ \\
\; \; \; \; A \; m() \; \kwoverride \; B \; \{\kwreturn \; \new B;\} \\
\} \\
\\
\kwinterface \; C \; \kwextends \; A \; \{ \\
\; \; \; \; A \; m() \; \kwoverride \; C \; \{\kwreturn \; \new C;\} \\
\} \\
\\
\kwinterface \; D \; \kwextends \; B, \; C \; \{ \\
\; \; \; \; A \; m() \; \kwoverride \; B \; \{\kwreturn \; \new D;\} \\
\} \\
\\
\kwinterface \; E \; \kwextends \; B \; \{ \\
\; \; \; \; A \; m() \; \kwoverride \; B \; \{\kwreturn \; \new E;\} \\
\} \\
\\
\kwinterface \; F \; \kwextends \; D, \; E \; \{ \\
\; \; \; \; A \; m() \; \kwoverride \; B \; \{\kwreturn \; \new F;\} \\
\; \; \; \; A \; n(B \; b) \; \kwoverride \; F \; \{\kwreturn \; b.m();\} \\
\} \\
\\
\new F.n(\new F)
\end{array}
\]

~\haoyuan{Unfortunately I think this example shows that it is hard to reuse
	$D.m$ on path $B$ and $E.m$ on path $B$ in $F$?}

\haoyuan{We can use the $\kwsuper$ keyword to access the originally defined methods
	in super types, but we cannot access the old updating methods.}

\haoyuan{Just like $\kwsuper.I::m()$ is equivalent to $\new I.m()$, maybe we can add
a degree of freedom to $\kwsuper$, for example, $\kwsuper.D::B::m()$ is equivalent to
$\new D.B::m()$, so we can use $\kwsuper.D::B::m()$ and $\kwsuper.E::B::m()$ inside interface $F$ for code reuse?}

Interfaces $A,B,C,D,E,F$ OK in type checking.

To type-check $\new F.n(\new F)$:
\begin{itemize}
	\item By (T-INVK), we need to calculate $\mtype(n, F)$.
	\item $\mtype(n, F) = B \to A$. And $\new F : B$.
	\item $\new F.n(\new F) : A$.
\end{itemize}

~

To compute \red{$\new F.n(\new F)$}:
\begin{itemize}
	\item By (C-RECEIVER), we compute \red{$\new F$}:
		\begin{itemize}
			\item By (C-STATICTYPE): \red{$<F> \new F$}.
		\end{itemize}
	\item By (C-ARGS), we compute \red{$\new F$}:
		\begin{itemize}
			\item By (C-STATICTYPE): \red{$<F> \new F$}.
		\end{itemize}
	\item Now we get \red{$(<F> \new F).n(<F> \new F)$}. By (S-INVK):
		\begin{itemize}
			\item Compute $\mbody(n, F, F) = \red{(B \; b, A \; b.m())}$.
			\item Replace \red{$b$} with \red{$<B> \new F$} in \red{$b.m()$}.
			\item Replace \red{$\kwthis$} with \red{$<F> \new F$} in \red{$b.m()$}.
		\end{itemize}
	\item Finally we get \red{$<A>((<B> \new F).m())$}.
	\item By (C-FREDUCE), we first compute \red{$(<B> \new F).m()$}:
		\begin{itemize}
			\item By (S-INVK), we compute \red{$\mbody(m, F, B)$}.
			\item In $\mbody$, we invoke \red{$\mostSpecific(m, F, B)$}.
			\item In $\mostSpecific$, \red{$set = \{B\}$, $\prune(set) = \{B\}$}.
			\item Back to $\mbody$, we invoke \red{$\mostSpecific_3(m, F, B)$}.
			\item In $\mostSpecific_3$, \red{$set = \{B,D,E,F\}$, $\prune(set) = \{F\}$}.
			\item Back to $\mbody$, we check \red{$F.m$} and return \red{$(-,A \; (\new F))$}.
			\item Back to (S-INVK).
			\item Replace \red{$\kwthis$} with \red{$<B> \new F$} in \red{$\new F$}.
			\item Finally we get \red{$<A> \new F$}.
		\end{itemize}
	\item Now we have \red{$<A>(<A> \new F)$}.
	\item By (C-ANNOREDUCE): \red{$<A> \new F$}.
\end{itemize}

\haoyuan{TODO: class encapsulation problem: interface A: m; interface B: m update A; interface C: m update B.}


