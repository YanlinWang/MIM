\section{Formalization}

\begin{itemize}
	\item Syntax + typing rules + Semantics + Auxiliary definitions
	\item Implementation: a simple type checker + interpreter in Scala
\end{itemize}

\subsection{Syntax}
See Figure~\ref{fig:syntax}.
$I$, $J$ represents interfaces. 
\kwsuper can only be used inside interface definition.

\begin{figure*}[htbp]
\begin{displaymath}
\begin{array}{l}
\begin{array}{llrl}
\text{Interfaces}   & IL & \Coloneqq & \interface{I}{I}{M} \\
\text{Methods}      & M  & \Coloneqq & \method{I}{m}{I}{x}{J}{e} \\
\text{Expressions}  & e  & \Coloneqq & x \mid
e.m(\overline{e}) \mid
\new{I} \mid
e.I::m(\overline{e}) \mid
\kwsuper.I::m(e) \\
\text{Context}      & \Gamma & \Coloneqq & x_1:I_1 ... x_n:I_n \\
\text{\red{Values}}       & v & \Coloneqq & <I>\new{J}
\end{array}
\end{array}
\end{displaymath}
\caption{Syntax.}\label{fig:syntax}
\end{figure*}

\subsection{Subtyping}
See Figure~\ref{fig:subtyping}.

\begin{figure*}[htbp]
\begin{mathpar}
	\subid \\
	\subtrans \\
	\subextends
\end{mathpar}
\caption{Subtyping.}\label{fig:subtyping}
\end{figure*}

\subsection{Typing Rules}
See Figure~\ref{fig:typingrules}.

\begin{figure*}[htbp]
\begin{mathpar}
	\tvar \\
	\tinvk \\
	\tpathinvk \\
	\tsuperinvk \\
	\tnew \\
	\tmethod \\
	\tintf
\end{mathpar}
\caption{Typing rules.}\label{fig:typingrules}
\end{figure*}

\subsection{Small-step Semantics}
See Figure~\ref{fig:smallstep}.

\begin{figure*}[htbp]
\begin{mathpar}
	\sinvk \\
	\spathinvk \\
	\ssuperinvk
\end{mathpar}
\caption{Small-step semantics.}\label{fig:smallstep}
\end{figure*}



\subsection{Congruence}
See Figure~\ref{fig:congruence}.

\begin{figure*}[htbp]
\deff
\begin{mathpar}
	\creceiver \\
	\red{\cpathreceiver} \\
	\red{\cargs} \\
	\red{\cpathargs} \\
	\red{\csuperargs} \\
	\cstatictype \\
	\cfreduce \\
	\cannoreduce
\end{mathpar}
\caption{Congruence.}\label{fig:congruence}
\end{figure*}



\subsection{Auxilary Definitions}


\subsubsection{\mbody}
\begin{mathpar}
	\inferrule* [left=]
	{C \{ m() \; \kwoverride \; C ... \} }
	{\mbody(m, C, A) = (\overline{X} \; \overline{x}, E \; e_0) \text{ IN } C}
	
	\inferrule* [left=]
	{C \{ m() \; \kwoverride \; A ... \} }
	{\mbody(m, C, A) = (\overline{X} \; \overline{x}, E \; e_0) \text{ IN } C}
	
	\inferrule* [left=]
	{   \mbody(m, C) = \{ A.m(), B.m(), ...\}
		\\ \nexists \; C.m()}
	{\mbody(m, C, A) = (\overline{X} \; \overline{x}, E \; e_0) \text{ IN } A}
\end{mathpar}

$$\interface{I}{I}{M}$$

$mbody(m, I)$ algorithm:
\begin{itemize}
	\item If m is defined in I directly, then return I.m()
	\item Else, let $\overline{I'} = mdefined(fathers(I))$, all ancestors of $I$ that has directly defined $m()$.
	\item $\overline{I''} = needed(\overline{I'})$, keep only interfaces that are needed, which are not super-interface of others.
	\item If $\overline{I''}$ is unique, then return this unique one. Else if any two I1,I2 in $\overline{I''}$ share a parent in $\overline{I'}$, then diamond conflict is detected, report error. Else return multiple $m()$s.
\end{itemize}



\subsubsection{\mtype}
$\mtype(m, C)$ algorithm:
\begin{itemize}
	\item If the result of $\mbody(m, C, A)$ is a unique method,\\
	$\method{I_0}{m}{I}{x}{J}{e_0}$,\\
	then $\mtype(m, C) = \overline{I} \to I_0$
	\item Else ($\Undefined$ or multiple methods returned), $\mtype(m, C) = \Error$
\end{itemize}



\subsubsection{\ext}
\ext(I,J) means interface $I$ (directly) extends $J$.
\begin{mathpar}
	\inferrule* [left=]
	{   \interface{I}{I}{M}
		\\ J \in \overline{I} }
	{\ext(I, J) = \kwtrue}      \\
	
	\inferrule* [left=]
	{}
	{\ext(I, J) = \kwfalse}
\end{mathpar}



\subsubsection{\collectMethods}
\[ \collectMethods(I) = \left( \bigcup_{I_i \in \overline{I}} \methods(I_i) \right) \bigcup \methods(I) \]
\[ \methods(I) = \overline{M}, \text{where } IT(I) = \interface{I}{I}{M} \]



\subsubsection{\needed}

\subsubsection{\only}
$\only(m, I)$ is true iff inside $I$ there is only one (direct) methoed $m$ definition.

\subsection{\pathcheck}
$$\forall P \in getSupTypes(I)$$

\begin{align*}
 set = \{ class | class \in getSupTypes(I) 
		\\ class.m \text{ defined in its body }
		\\ class <: P \}
\end{align*}

$$ prune(set) = \{x \in set | \nexists y \in set, y <: x, y \neq x \} $$
$$ |prune(set)| <= 1 $$ 
